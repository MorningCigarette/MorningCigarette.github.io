<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="C#12 中的集合表达式 经典集合初始化器 自 C# 3.0 起，我们就有了 “集合初始化器” 。它们采用 {} 模式来初始化任何实现了 Add() 方法的 IEnumerable 实现。例如，这会创建一个新的 List<string> 并用 5 个值初始化它：\n"><title>C#12 中的集合表达式</title><link rel=canonical href=https://MorningCigarette.github.io/p/collection-expressions/><link rel=stylesheet href=/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css><meta property='og:title' content="C#12 中的集合表达式"><meta property='og:description' content="C#12 中的集合表达式 经典集合初始化器 自 C# 3.0 起，我们就有了 “集合初始化器” 。它们采用 {} 模式来初始化任何实现了 Add() 方法的 IEnumerable 实现。例如，这会创建一个新的 List<string> 并用 5 个值初始化它：\n"><meta property='og:url' content='https://MorningCigarette.github.io/p/collection-expressions/'><meta property='og:site_name' content='Sutra Library'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2024-11-14T00:00:00+00:00'><meta property='article:modified_time' content='2024-11-14T00:00:00+00:00'><meta name=twitter:title content="C#12 中的集合表达式"><meta name=twitter:description content="C#12 中的集合表达式 经典集合初始化器 自 C# 3.0 起，我们就有了 “集合初始化器” 。它们采用 {} 模式来初始化任何实现了 Add() 方法的 IEnumerable 实现。例如，这会创建一个新的 List<string> 并用 5 个值初始化它：\n"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_5ab8cc3a8e310b0d.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Sutra Library</a></h1><h2 class=site-description>Love is the one thing we’re capable of perceiving that transcends time and space.</h2></div></header><ol class=menu-social><li><a href=https://github.com/MorningCigarette target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>about</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#经典集合初始化器>经典集合初始化器</a></li><li><a href=#使用集合表达式统一语法>使用集合表达式统一语法</a></li><li><a href=#推断接口类型>推断接口类型</a></li><li><a href=#针对-readonlyspan-的高效自动-stackalloc>针对 <code>ReadOnlySpan</code> 的高效自动 <code>stackalloc</code></a></li><li><a href=#集合表达式使重构更简单>集合表达式使重构更简单</a></li><li><a href=#空集合>空集合</a></li><li><a href=#使用展开运算符spread-element从其他集合构建集合>使用展开运算符（spread element）从其他集合构建集合</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/c%23/>C#</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/collection-expressions/>C#12 中的集合表达式</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Nov 14, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 8 分钟</time></div></footer></div></header><section class=article-content><h1 id=c12-中的集合表达式>C#12 中的集合表达式</h1><h2 id=经典集合初始化器>经典集合初始化器</h2><p>自 <code>C# 3.0</code> 起，我们就有了 “集合初始化器” 。它们采用 <code>{}</code> 模式来初始化任何实现了 <code>Add()</code> 方法的 <code>IEnumerable</code> 实现。例如，这会创建一个新的 <code>List&lt;string></code> 并用 5 个值初始化它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>var</span> <span class=n>values</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=p>{</span> <span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=s>&#34;3&#34;</span><span class=p>,</span> <span class=s>&#34;4&#34;</span><span class=p>,</span> <span class=s>&#34;5&#34;</span> <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>幕后，编译器生成的代码看起来像这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>List</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>values</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl><span class=n>values</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>values</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=s>&#34;2&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>values</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=s>&#34;3&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>values</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=s>&#34;4&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>values</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=s>&#34;5&#34;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p><code>C#</code> 中的数组初始化有其特别之处，你可以用比其他集合更多的方法来初始化它们，尽管看起来与标准集合初始化器相似：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>var</span> <span class=n>values1</span> <span class=p>=</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=s>&#34;3&#34;</span><span class=p>,</span> <span class=s>&#34;4&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>values2</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>string</span><span class=p>[</span><span class=m>4</span><span class=p>]</span> <span class=p>{</span> <span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=s>&#34;3&#34;</span><span class=p>,</span> <span class=s>&#34;4&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>string</span><span class=p>[]</span> <span class=n>values3</span> <span class=p>=</span> <span class=p>{</span> <span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=s>&#34;3&#34;</span><span class=p>,</span> <span class=s>&#34;4&#34;</span> <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>这些工作方式与集合初始化器不同；这里没有调用 <code>Add()</code> 方法。相反，编译器生成的是如果你手动做这一切时同样的初始化代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>string</span><span class=p>[]</span> <span class=n>array</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>string</span><span class=p>[</span><span class=m>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;1&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;2&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;3&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=m>3</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;4&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>我们已经讨论了通用集合（如 <code>List</code> ）和数组的集合初始化器，还有在 <code>Span</code> 世界中变得更为有用的 <code>stackalloc</code> 表达式，因为不需要使用 <code>unsafe</code> 代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>Span</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>array</span> <span class=p>=</span> <span class=k>stackalloc</span> <span class=p>[]{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>幕后，编译器将这个 <code>stackalloc</code> 初始化器转化为一些类似这样的 <code>unsafe</code> 代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kd>unsafe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>byte</span><span class=p>*</span> <span class=n>num</span> <span class=p>=</span> <span class=k>stackalloc</span> <span class=kt>byte</span><span class=p>[</span><span class=m>16</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>*(</span><span class=kt>int</span><span class=p>*)</span><span class=n>num</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>*(</span><span class=kt>int</span><span class=p>*)(</span><span class=n>num</span> <span class=p>+</span> <span class=m>4</span><span class=p>)</span> <span class=p>=</span> <span class=m>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>*(</span><span class=kt>int</span><span class=p>*)(</span><span class=n>num</span> <span class=p>+</span> <span class=p>(</span><span class=n>nint</span><span class=p>)</span><span class=m>2</span> <span class=p>*</span> <span class=p>(</span><span class=n>nint</span><span class=p>)</span><span class=m>4</span><span class=p>)</span> <span class=p>=</span> <span class=m>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>*(</span><span class=kt>int</span><span class=p>*)(</span><span class=n>num</span> <span class=p>+</span> <span class=p>(</span><span class=n>nint</span><span class=p>)</span><span class=m>3</span> <span class=p>*</span> <span class=p>(</span><span class=n>nint</span><span class=p>)</span><span class=m>4</span><span class=p>)</span> <span class=p>=</span> <span class=m>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Span</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>array</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Span</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;(</span><span class=n>num</span><span class=p>,</span> <span class=m>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这段代码在栈上创建了一个数组，然后通过指针运算遍历每个元素，设置每个值。</p><h2 id=使用集合表达式统一语法>使用集合表达式统一语法</h2><p>我们已经看到至少有三种不同的场景下我们在初始化集合：</p><ul><li>数组</li><li>类似 <code>List</code> 的集合</li><li>使用 <code>stackalloc</code> 的 <code>ReadOnlySpan</code></li></ul><p>每种情况都需要稍微不同的语法，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>array</span> <span class=p>=</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>List</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>list</span> <span class=p>=</span> <span class=k>new</span><span class=p>()</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>HashSet</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>hashset</span> <span class=p>=</span> <span class=k>new</span><span class=p>()</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>ReadOnlySpan</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>span</span> <span class=p>=</span> <span class=k>stackalloc</span> <span class=p>[]</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>这有点混乱和烦人。<code>C#12</code> 中引入的<strong>集合表达式</strong>提供了一种简化、统一的语法，适用于所有这些不同的集合类型。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>array</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>List</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>list</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>HashSet</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>hashset</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>ReadOnlySpan</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>span</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div><p>集合表达式在所有集合类型上的一致性是一个真正的优势，但这并不是唯一的优点。集合表达式相比集合初始化器可以提供性能优势（我们将在后续文章中探讨），以及额外的功能。</p><h2 id=推断接口类型>推断接口类型</h2><p>想象一下，你想要创建一个集合，但你只关心它实现了 <code>IEnumerable</code> 。你需要自己决定使用哪个后端类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>list1</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>list2</span> <span class=p>=</span> <span class=k>new</span> <span class=n>HashSet</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>list3</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[]</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>那么应该选择哪一个呢？如果所有你需要做的就是枚举列表，那理论上选择哪种类型都不应该重要，对吧？那么正确的选项是什么？</p><p>使用集合表达式，你可以将此决策委托给编译器。你可以不指定后端类型，而由编译器来决定。而且，集合表达式的额外优点是更加简洁：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>ienumerable</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>IList</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>ilist</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>IReadOnlyCollection</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>icollection</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div><p>幕后，编译器完全透明地创建了一个实现所需接口的集合，所以你无需考虑这一点。</p><p>值得注意的是，虽然编译器会自动为接口集合选择一个具体的类型，但你需要指定<em>某种</em>类型。例如，你不能使用 <code>var</code> ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>var</span> <span class=n>values</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span> <span class=c1>// ❌ 编译错误，CS9176：集合表达式没有目标类型</span>
</span></span><span class=line><span class=cl><span class=n>Sum</span><span class=p>(</span><span class=n>values</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Sum</span><span class=p>([</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>]);</span> <span class=c1>// ✅ 这是可行的</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>Sum</span><span class=p>(</span><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>v</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>v</span><span class=p>.</span><span class=n>Sum</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>问题在于，根据 C#编译器的工作方式，它无法推断 <code>values</code> 的类型应为 <code>IEnumerable&lt;int></code> ，因此抛出了错误。未来版本的 C#可能会改变这种情况，但可能的解决方案是始终选择 <code>int[]</code> ，这并不一定是最优的，所以不要抱太大希望。</p><h2 id=针对-readonlyspan-的高效自动-stackalloc>针对 <code>ReadOnlySpan</code> 的高效自动 <code>stackalloc</code></h2><p>对于 <code>ReadOnlySpan</code> 和 <code>Span</code> 实例来说，如果你只使用集合初始化器，情况也类似。如果你只需要在 <code>Span</code> 或 <code>ReadOnlySpan</code> 中存储一些数据，那么使用集合初始化器就需要决定将数据放在哪里，然后再从中获取 <code>Span</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>Span</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>spans2</span> <span class=p>=</span> <span class=k>stackalloc</span><span class=p>[]</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span> <span class=c1>// 栈上分配数组</span>
</span></span><span class=line><span class=cl><span class=n>Span</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>spans3</span> <span class=p>=</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>};</span> <span class=c1>// 在堆上分配</span>
</span></span><span class=line><span class=cl><span class=n>Span</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>spans4</span> <span class=p>=</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=s>&#34;3&#34;</span><span class=p>,</span> <span class=s>&#34;4&#34;</span> <span class=p>};</span> <span class=c1>// 不能直接使用 stackalloc 分配字符串数组</span>
</span></span></code></pre></td></tr></table></div></div><p>虽然这不是一个很大的决策，通常只有两个合理的选择，但还是需要额外考虑的事情。此外，你不能直接使用 <code>stackalloc</code> 为 <code>string[]</code> 分配内存，除非通过一些 <code>InlineArray</code> 的技巧 。</p><p>使用集合表达式，你可以再次将此决策委托给编译器，它会做出正确的处理。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>ReadOnlySpan</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>readonlyspans</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>Span</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>spans</span> <span class=p>=</span> <span class=p>[</span><span class=s>&#34;1&#34;</span><span class=p>,</span> <span class=s>&#34;2&#34;</span><span class=p>,</span> <span class=s>&#34;3&#34;</span><span class=p>,</span> <span class=s>&#34;4&#34;</span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div><p>在系列的后续部分，你会发现这些特定的集合表达式案例被<strong>高度优化</strong>！</p><h2 id=集合表达式使重构更简单>集合表达式使重构更简单</h2><p>到目前为止，我展示的所有例子都是将集合表达式赋值给变量，但实际上你也可以直接将集合表达式作为方法参数使用，比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Linq</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Collections.Generic</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 创建一个接受IEnumerable&lt;int&gt;的方法</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>Sum</span><span class=p>(</span><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>values</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>values</span><span class=p>.</span><span class=n>Sum</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 使用集合表达式调用方法</span>
</span></span><span class=line><span class=cl><span class=n>Sum</span><span class=p>([</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>]);</span>
</span></span></code></pre></td></tr></table></div></div><p>这种模式的一个好处是，如果我改变了 <code>Sum()</code> 的签名，我不需要改变调用站点。相比之下，如果你使用集合初始化器：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=c1>// 如果方法接受数组...</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>Sum1</span><span class=p>(</span><span class=kt>int</span><span class=p>[]</span> <span class=n>values</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>values</span><span class=p>.</span><span class=n>Sum</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>Sum1</span><span class=p>(</span><span class=k>new</span> <span class=p>[]</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>});</span> <span class=c1>// 必须使用数组语法</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果方法接受IEnumerable...</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>Sum2</span><span class=p>(</span><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>values</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>values</span><span class=p>.</span><span class=n>Sum</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>Sum2</span><span class=p>(</span><span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>});</span> <span class=c1>// 必须使用显式类型，如List或类似</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果方法接受ReadOnlySpan...</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>Sum3</span><span class=p>(</span><span class=n>ReadOnlySpan</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>values</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>total</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=kt>var</span> <span class=k>value</span> <span class=k>in</span> <span class=n>values</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>total</span> <span class=p>+=</span> <span class=k>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>Sum3</span><span class=p>(</span><span class=k>new</span> <span class=p>[]{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span> <span class=p>});</span> <span class=c1>// 必须选择标准数组或者使用stackalloc分配的数组</span>
</span></span></code></pre></td></tr></table></div></div><p>如果使用集合表达式，那么我们可以使用完全相同的语法来调用所有三个 <code>Sum()</code> 实现：</p><p><code>Sum1([ 1, 2, 3, 4 ]); Sum2([ 1, 2, 3, 4 ]); Sum3([ 1, 2, 3, 4 ]);</code></p><p>并且，编译器会使用最有效的实现方式来创建所需类型的集合。</p><p>这看起来可能是一件小事，而且在某种程度上确实是这样，但正是所有这些小小的便利特性使得集合表达式成为一个非常整洁的功能！整体而言，正是这些微小的方便性让集合表达式的使用变得极为顺手和高效。</p><h2 id=空集合>空集合</h2><p>在 <code>C#</code> 中，集合表达式的一个特性是编译器明确识别空集合的语法。这意味着你不再需要写像下面这样的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>var</span> <span class=n>empty</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[]{};</span> <span class=c1>// 通常你不应该这样做...</span>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>empty</span> <span class=p>=</span> <span class=n>Array</span><span class=p>.</span><span class=n>Empty</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;();</span> <span class=c1>// ...相反，更倾向于使用这行代码!</span>
</span></span></code></pre></td></tr></table></div></div><p>现在，你可以使用 <code>[]</code> 来生成一个适当的空集合版本，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>empty</span> <span class=p>=</span> <span class=p>[];</span>
</span></span></code></pre></td></tr></table></div></div><p>集合表达式相比于显式初始化有两大主要优势：</p><ul><li>编译器可以选择创建空集合的最有效方式，比如选择 <code>Array.Empty()</code>（或其等价方法）。</li><li>对于所有集合类型，你可以使用一致的语法。</li></ul><p>以下示例展示了多种集合类型，以及如何使用 <code>[]</code> 来创建它们的空版本。每行代码后的注释显示了编译器为特定类型生成的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>array</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// Array.Empty()</span>
</span></span><span class=line><span class=cl><span class=n>HashSet</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>hashset</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// new HashSet&lt;int&gt;()</span>
</span></span><span class=line><span class=cl><span class=n>List</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>list</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// new List&lt;int&gt;()</span>
</span></span><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>ienumerable</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// Array.Empty()</span>
</span></span><span class=line><span class=cl><span class=n>ICollection</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>icollection</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// new List&lt;int&gt;()</span>
</span></span><span class=line><span class=cl><span class=n>IList</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>ilist</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// new List&lt;int&gt;()</span>
</span></span><span class=line><span class=cl><span class=n>IReadOnlyCollection</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>readonlycollection</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// Array.Empty()</span>
</span></span><span class=line><span class=cl><span class=n>IReadOnlyList</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>readonlyList</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// Array.Empty()</span>
</span></span><span class=line><span class=cl><span class=n>Span</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>span</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// default(Span&lt;int&gt;)</span>
</span></span><span class=line><span class=cl><span class=n>ReadOnlySpan</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>readonlyspan</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// default(ReadOnlySpan&lt;int&gt;)</span>
</span></span><span class=line><span class=cl><span class=n>ImmutableArray</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>immutablearray</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// ImmutableArray.CreateRange(Array.Empty())</span>
</span></span><span class=line><span class=cl><span class=n>ImmutableList</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>immutablelist</span> <span class=p>=</span> <span class=p>[];</span> <span class=c1>// ImmutableList.Create(default(ReadOnlySpan&lt;int&gt;));</span>
</span></span></code></pre></td></tr></table></div></div><p>如你所见，编译器尽可能地高效；如果类型是可变的，如 <code>HashSet</code> 或 <code>List</code>，那么它只能创建一个新的实例；但如果可以使用不分配内存的版本，如 <code>Array.Empty()</code>，那么它就会采用这种方式！请注意，在最后一个示例中，<code>ImmutableArray</code> 和 <code>ImmutableList</code> 使用了不同的构造函数来创建空集合，因为它们是不可变集合。</p><h2 id=使用展开运算符spread-element从其他集合构建集合>使用展开运算符（spread element）从其他集合构建集合</h2><p>我们已经了解了集合表达式的两个好处：</p><ul><li>一致的语法</li><li>高效的编译器生成实现</li></ul><p>集合表达式的另一个重要特性是 <em>展开运算符</em> (<code>..</code>)。这使你能够更容易地从其他集合实例构建新的集合。</p><p>举个具体的例子，假设你有两个 <code>IEnumerable</code> 集合，并且你想将它们作为数组连接起来。使用 LINQ，这是相当容易做到的，因为它提供了专门用于此类操作的扩展方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>ConcatAsArray</span><span class=p>(</span><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>first</span><span class=p>,</span> <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>first</span><span class=p>.</span><span class=n>Concat</span><span class=p>(</span><span class=n>second</span><span class=p>).</span><span class=n>ToArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>很好，但是如果现在你需要处理的是 <code>ReadOnlySpan</code> 而不是 <code>IEnumerable</code> 呢？不幸的是，正如我们之前讨论的那样，<code>ReadOnlySpan</code> 不实现 <code>IEnumerable</code> 接口，所以我们可能需要这样做：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>ConcatAsArray</span><span class=p>(</span><span class=n>ReadOnlySpan</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>first</span><span class=p>,</span> <span class=n>ReadOnlySpan</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>list</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;(</span><span class=n>first</span><span class=p>.</span><span class=n>Length</span> <span class=p>+</span> <span class=n>second</span><span class=p>.</span><span class=n>Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span><span class=p>.</span><span class=n>AddRange</span><span class=p>(</span><span class=n>first</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span><span class=p>.</span><span class=n>AddRange</span><span class=p>(</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>list</span><span class=p>.</span><span class=n>ToArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这虽然不是 <em>糟糕</em>，但仍然让人感到恼火，因为对于每种不同的集合类型都得考虑这些细节。而使用集合表达式和展开运算符，我们得到了一个简洁的快捷方式，它可以用于所有受支持的集合类型。上述两种重载都可以用同样的方式实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>ConcatAsArray</span><span class=p>(</span><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>first</span><span class=p>,</span> <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>second</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>[..</span><span class=n>first</span><span class=p>,</span> <span class=p>..</span><span class=n>second</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>ConcatAsArray</span><span class=p>(</span><span class=n>ReadOnlySpan</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>first</span><span class=p>,</span> <span class=n>ReadOnlySpan</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>second</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>[..</span><span class=n>first</span><span class=p>,</span> <span class=p>..</span><span class=n>second</span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div><p>而且，由于集合表达式的一致性，如果你更改 <code>ConcatAsArray()</code> 方法的参数 <em>或者</em> 返回类型，你完全不需要修改集合表达式本身，它依旧可以正常工作！</p><p><code>..</code> 运算符意味着 “写出集合中的所有值” ，因此再举一个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>array</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>oddValues</span> <span class=p>=</span> <span class=n>array</span><span class=p>.</span><span class=n>Where</span><span class=p>(</span><span class=kt>int</span><span class=p>.</span><span class=n>IsOddInteger</span><span class=p>);</span> <span class=c1>// 1, 3</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>evenValues</span> <span class=p>=</span> <span class=p>[..</span><span class=n>array</span><span class=p>.</span><span class=n>Where</span><span class=p>(</span><span class=kt>int</span><span class=p>.</span><span class=n>IsEvenInteger</span><span class=p>)];</span>      <span class=c1>// 2, 4</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>allValues</span> <span class=p>=</span> <span class=p>[..</span><span class=n>oddValues</span><span class=p>,</span> <span class=p>..</span><span class=n>evenValues</span><span class=p>];</span>             <span class=c1>// 1, 3, 2, 4</span>
</span></span></code></pre></td></tr></table></div></div><p>上述代码多次使用了展开运算符，但在每种情况下，它都意味着 “写出集合的所有元素” 。所以在最后一步中，<code>allValues</code> 包含了 <code>oddValues</code> 中的所有元素，后面跟着 <code>evenValues</code> 中的所有值。</p><p>你也可以在集合表达式中混合单一值和展开集合，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>arr</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>myValues</span> <span class=p>=</span> <span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=p>..</span><span class=n>arr</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>6</span><span class=p>];</span> <span class=c1>// 0, 1, 2, 3, 4, 5, 6</span>
</span></span></code></pre></td></tr></table></div></div><p>最终结果就像是遍历了 <code>arr</code> 并添加了每个值一样。</p><p>注意，展开运算符 <code>..</code> 与 <em>范围运算符</em>（如 <code>1..3</code> 或 <code>2..^</code> 中的 <code>..</code>）是 <em>不同</em> 的，后者用于对数组进行 <em>索引</em>。然而，你可以结合使用它们，先用 <em>范围</em> 来选择元素子集，然后将它们 <em>展开</em> 到集合表达式中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>primes</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>7</span><span class=p>,</span> <span class=m>9</span><span class=p>,</span> <span class=m>11</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>some</span> <span class=p>=</span> <span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=p>..</span><span class=n>primes</span><span class=p>[</span><span class=m>1.</span><span class=p>.^</span><span class=m>1</span><span class=p>]];</span> <span class=c1>// 0, 2, 3, 5, 7, 9</span>
</span></span></code></pre></td></tr></table></div></div><p>这段代码使用 <code>1..^1</code> 范围运算符取 <code>primes</code> 数组的第1个至N-1个元素（即 <code>2, 3, 5, 7, 9</code>），然后在集合表达式中使用展开 <code>..</code>。</p><p>集合表达式为创建集合添加了一种很好的对称性（在重构从一种集合类型到另一种时特别有用），并且通过展开运算符使集合的组合变得更加简单。但集合表达式不仅仅是关于语法。重要的是，集合表达式为编译器提供了优化其生成代码的选项。</p><p>在下一篇中，我们将探讨更多类型的集合，如 <code>T[]</code> 和 <code>ReadOnlySpan&lt;T></code>，看看它们在使用集合表达式时是如何被高度优化的。</p><p><a class=link href="https://www.koudingke.cn/go?link=https%3a%2f%2fandrewlock.net%2fbehind-the-scenes-of-collection-expressions-part-1-introducing-collection-expressions-in-csharp12%2f" target=_blank rel=noopener>英文原文</a></p></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/c%23test/><div class=article-details><h2 class=article-title>C#高频面试题</h2></div></a></article><article><a href=/p/pyandcsharp/><div class=article-details><h2 class=article-title>Python 的 self 和 C# 的 this</h2></div></a></article><article><a href=/p/middleware/><div class=article-details><h2 class=article-title>C#.NET 中间件详解</h2></div></a></article><article><a href=/p/serializationinrestsharp/><div class=article-details><h2 class=article-title>System.Text.Json 和 Newtonsoft.Json 默认序列化时的大小写行为差异</h2></div></a></article><article><a href=/p/asyncawait/><div class=article-details><h2 class=article-title>最容易踩坑的6个async/await 使用错误</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=MorningCigarette/MorningCigarette.github.io data-repo-id=R_kgDOMfZTRw data-category=Announcements data-category-id=DIC_kwDOMfZTR84ChaA8 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark")}})()</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 Sutra Library</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>