[{"content":"And we count these moments. These moments when we dare to aim higher, to break barriers, to reach for the stars, to make the unknown known. We count these moments as our proudest achievements.\n","date":"2022-03-06T00:00:00Z","image":"https://MorningCigarette.github.io/p/hello-world/cover_hu_e95a4276bf860a84.jpg","permalink":"https://MorningCigarette.github.io/p/hello-world/","title":"Hello World"},{"content":" C#值类型和引用类型的区别是什么 (30) C#字典的底层实现是什么 (26) 请解释什么是垃圾回收（GC）及其工作原理？ (25) C#中什么是装箱和拆箱？ (18) 请详述在C#中类(class)与结构(struct)的异同？ (9) 怎么防止过度的GC产生？ (8) C#中的反射（Reflection）是什么？它有哪些应用场景？ (8) 请说明c#委托和事件的区别 (7) C#中什么是值类型与引用类型？ (7) 请解释什么是泛型，如何在C#中使用泛型？ (6) C#中abstract class和interface有什么区别? (5) C#中的委托是什么？事件是不是一种委托？ (5) 请说明C#协程和线程的概念 (5) ArrayList和List的区别是什么 (4) 请说明垃圾回收机制何时自动释放，何时需要手动释放 (4) C#中如何实现异步编程？ (4) 请介绍C#中的数据结构，如列表（List）和字典（Dictionary）等 (3) 简述dictionary发生哈希冲突时的解决方法 (3) C#中List的底层是什么 (2) C#中的事件是什么？ (2) c#当中int和long分别占用多少字节 (2) 说明C#如何把一个值类型转换为引用类型 (2) 请说明 private、protected、public、internal 的访问权限 (2) C#中值传递与引用传递的区别是什么？ (2) C#中堆和栈的区别？ (2) C#反射怎么获取一个类然后调用里面的方法 (2) 如何在C#中实现依赖注入？ (2) 如果有数以百万计的数据要插入哈希表，应该如何尽量减少哈希冲突 (2) 请解释异步编程的概念、工作原理以及实现方式 (2) 请阐述ASP.NET和ASP.NET Core的区别。 (2) 怎么去设计一个对象池？（用具体的程序逻辑、数据结构、对外提供哪些接口） (2) C# List是什么类型的容器 C# yield的作用是什么 C# 成员变量和成员函数前加static的作用？ C#中IEnumerator的概念和作用是什么 C#中out关键字如何实现将参数传到方法外？ C#中实现多线程的方式有哪些？ C#中引用类型加ref和不加ref有什么差别？ C#中用static定义构造函数会怎么样 C#中的List和数组的区别是什么 C#所有类的基类是什么 C#添加事件和删除事件一般通过+=或-=，如果添加两次+=同一个事件，调用会执行一次还是两次 C#的协程是什么 HashSet和Dictionary的区别是什么 int?和int有什么区别 int32的最大值2147483647加1之后等于多少 List中如果中间删除了某些元素，List会做什么操作，原数组会有什么问题 sealed关键字的作用是什么 什么时候使用class，什么时候使用struct 列举哪些情况会发生装箱 前台线程和后台线程有什么差别？ 当字符串操作非常频繁时，如何进行优化 简述 readonly 关键字的作用 简述C# dictionary查询的复杂度是多少，为什么 简述C#装箱拆箱时，在内存上发生了什么变化 请列举Using关键字的用法 请列举引用类型和值类型，说明它们的数据存储结构，以及拆装箱时底层发生了什么 请简述装箱的危害 请说明C#中拆装箱操作的运行机制 请说明StringBuilder和String的区别，拼接字符串时的区别，以及StringBuild AOT打包项目后，是否还能使用反射 C#中两个线程之间如何实现通信机制？ C#中参数传递 ref 与 out 的区别？ C#中的partial类是什么？它有什么用途？ C#中的互斥量和锁分别是什么？ C#中的扩展方法是什么，如何使用？ C#中的管道如何实现？ c#可否对内存直接操作？ C#实现多态的过程中 overload 重载 与override 重写的区别？ C#闭包和匿名表达式在什么情况下会产生GC Lock锁的是一个对象，对这个对象有什么要求？ Parallel的应用场景有哪些 不使用反射，有什么办法可以实现类似的效果 为什么数组查找比List快？ 分析C# Lambda表达式及其性能 协程是否算是异步 在C#中如何让GC延迟调用 在C#中如何进行深拷贝？ 多个线程之间访问同一个数据时如何保证数据的线程安全，如何处理多线程并发安全问题？ 如何解决装箱拆箱带来的性能消耗 如果用字符串作为dictionary的键，会有什么问题和性能损耗 当await异步等待加载网络AB包出错时，应如何处理 接口传递结构体时，是进行装箱还是拆箱操作？ 是否了解 unity 的垃圾回收机制 有一个积分变量，在操作过程中存在频繁拆装箱的情况，如何进行优化；若积分最多只有1000，又该如何优化 简述C# GC区域划分 简述C#中的泛型（Generic）及其优势。 线程池相对于基础的线程有什么优缺点？ 设置线程池的最大进程数的目的是什么？ 说一下C#的编译流程 请介绍各种锁的概念和应用 请解释为什么GC会产生卡顿 请详细说明C#内存分配情况，包括string对象、StringBuilder对象和const修饰的变 请说明Using里面用到哪些固定类型，工作原理和机制，在内存中发生了什么，是否可以在里面使用多线程 请说明对 DI 和 IOC 的了解，以及.NET 内置容器的三种生命周期 请说明对异步多线程的看法以及异步多线程可能导致的问题 请阐述对IOC与AOP的理解 请阐述对ORM框架的理解，列举认识的ORM框架并说明常用的有哪些 请阐述数据库连接池释放的原理，是否使用到了垃圾回收机制以及原因 C#中的多线程如何实现？ 请阐述异步、多线程的底层原理，以及在项目中的应用和遇到的问题 ADO.NET常用对象有哪些？ byte a = 255; a += 5; a的值是多少？ C#中的LINQ是什么？它有哪些主要组件？ new关键字的作用 Strings = new String(“xyz”); 创建了几个String Object? 什么是LINQ？请给出一个简单示例。 什么是NuGet？如何在C#项目中使用。 在ASP.NET中所有的自定义用户控件都必须继承自？ 字符串中string str=null和string str=\u0026ldquo;\u0026ldquo;和string str=strin 请描述C#中的字符串格式化方法。 请解释C#中的foreach循环的工作原理。 请解释C#中的命名空间（Namespace）及其作用。 C#中如何实现单例模式？ C#中用sealed修饰的类有什么特点？ C#中的Attributes是什么？它们的用途是什么？ C#中的Serialization和Deserialization是什么？ C#中的Task和Thread的区别是什么？ C#中的动态类型（dynamic）和var关键字有什么区别？ C#中的多线程编程是怎样的？简述Thread、ThreadPool和Task的区别。 C#中的属性和字段有什么区别？ C#中的异常处理机制是怎样的？try-catch-finally块的作用是什么？ C#中的构造函数和析构函数有什么区别？ C#中的版本控制（Versioning）如何管理？ C#中的索引器是什么？如何创建自定义索引器？ C#中的集合（Collection）有哪些主要类型？它们各自的特点是什么？ C#静态构造函数特点是什么？ const和readonly有什么区别？ CTS、CLS、CLR分别作何解释 ORM中的延迟加载与直接加载有什么异同？ 什么叫应用程序域(AppDomain) 什么是ASP.NET中的Web API？ 什么是MVC架构，它是如何在C#中实现的？ 什么是MVC模式 什么是多态？如何在C#中实现多态？ 什么是强类型，什么是弱类型？哪种更好些？为什么? 什么是数据绑定？如何在C#中实现？ 什么是数据访问层（DAL）？如何实现它？ 什么是线性链表和双向链表的区别？ 什么是虚函数？什么是抽象函数？ 在.NET托管代码总我们不必担心内存泄漏，这是因为？ 如何在C#中实现接口的多重继承？ 描述C#中的垃圾回收机制（Garbage Collection）。 描述C#中的构造函数和析构函数的作用及用法。 简述C#中的委托（Delegate）和匿名方法（Anonymous Method）。 简述Func与Action的区别？ 请描述ASP.NET中的路由机制。 请描述C#中的可空类型（Nullable Types）。 请描述如何在C#中处理异常。 请解释C#中字符串的不变性。 请解释C#中的lambda表达式及其语法。 请解释C#中的属性（Property）及其访问器（Accessor）。 请解释C#中的特性（Attribute）及其作用。 请解释C#中的锁（lock）语句及其使用场景。 请解释什么是async和await，以及它们的使用场景。 请解释如何处理JSON数据。 请阐述MVC与MVVM模式的区别。 C#中如何实现命令模式？ 什么是反序列化攻击？如何防范？ 请解释C#中的锁自由（Lock-free）编程模型。 请解释如何处理并发问题。 ","date":"2025-10-30T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/c%23test/","title":"C#高频面试题"},{"content":" 🧩 一、基本作用对比 对比点 Python 中的 self C# 中的 this 含义 当前对象的引用（实例本身） 当前对象的引用（实例本身） 显式性 必须显式写出在方法参数中（通常命名为 self） 编译器隐式提供，在实例方法中自动可用 是否关键字 不是关键字，只是约定俗成的名字（可改成别的） 是语言关键字 使用场景 类的实例方法第一个参数必须传入 self 类的实例方法可直接使用 this 静态方法是否可用 不可用，除非手动传实例 不可用，只能用于实例方法 🧠 二、示例对比 🐍 Python 1 2 3 4 5 6 class Person: def __init__(self, name): self.name = name # self 指当前实例 def greet(self): print(f\u0026#34;Hello, I\u0026#39;m {self.name}\u0026#34;) 使用：\n1 2 p = Person(\u0026#34;Alice\u0026#34;) p.greet() # 等价于 Person.greet(p) ✅ 注意：调用 p.greet() 时，Python 自动传入 self=p。\n💻 C# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Person { private string name; public Person(string name) { this.name = name; // this 指当前实例 } public void Greet() { Console.WriteLine($\u0026#34;Hello, I\u0026#39;m {this.name}\u0026#34;); } } 使用：\n1 2 var p = new Person(\u0026#34;Alice\u0026#34;); p.Greet(); // 编译器自动绑定 this = p ✅ 在 C# 中不需要显式传参，this 是隐式存在的。\n⚙️ 三、调用机制差异 对比点 Python C# 方法本质 实例方法其实是普通函数，通过绑定对象成为“方法” 实例方法是类成员，编译器自动关联实例 调用本质 p.greet() → Person.greet(p) p.Greet() → 编译器自动传递 this 函数与方法界限 较模糊（函数本身独立于类存在） 明确区分（方法绑定在类型上） 🧩 四、可用场景差异 场景 Python (self) C# (this) 引用实例成员 self.name this.name（也可省略） 区分同名变量 self.name = name（手动） this.name = name（常用） 链式调用 return self 可实现 return this 可实现 静态方法 @staticmethod 不带 self static 方法不能用 this 类方法 @classmethod 用 cls（类本身） 没有类似的机制（但可用泛型或反射实现） 💡 五、总结一句话 self 是 Python 显式传递的实例引用； this 是 C# 编译器隐式提供的实例引用。\n","date":"2025-10-28T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/pyandcsharp/","title":"Python 的 self 和 C# 的 this"},{"content":" 🧩 一、单个星号 * —— 接收「任意数量的位置参数」 1 2 def foo(*args): print(args) 调用：\n1 2 foo(1, 2, 3) # 输出: (1, 2, 3) 📘 含义：\n*args 会把传入的多个位置参数打包成一个元组 (tuple)； 名字 args 只是惯例，你可以写成任何名字，比如 *numbers。 ✅ 示例：\n1 2 3 4 def add(*nums): return sum(nums) print(add(1, 2, 3, 4)) # 10 🧩 二、两个星号 ** —— 接收「任意数量的关键字参数」 1 2 def foo(**kwargs): print(kwargs) 调用：\n1 2 foo(a=1, b=2, c=3) # 输出: {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} 📘 含义：\n**kwargs 会把所有的关键字参数打包成一个字典 dict； 名字 kwargs 也是惯例，可以换成任意合法标识符。 ✅ 示例：\n1 2 3 4 5 def print_info(**info): for k, v in info.items(): print(f\u0026#34;{k} = {v}\u0026#34;) print_info(name=\u0026#34;Alice\u0026#34;, age=25) 🧩 三、函数定义中单独的 * —— 限制后面参数必须用关键字传递 1 2 def foo(a, b, *, c, d): print(a, b, c, d) 调用：\n1 2 foo(1, 2, c=3, d=4) # ✅ 正确 foo(1, 2, 3, 4) # ❌ 错误：c、d 必须用关键字传递 📘 含义：\n单独一个 * 表示“从此处开始的参数必须使用关键字指定”； 常用于提高函数调用的可读性和安全性。 ✅ 示例：\n1 2 3 4 5 def move(x, y, *, speed=1): print(f\u0026#34;Moving to ({x},{y}) at speed {speed}\u0026#34;) move(10, 20, speed=5) # ✅ move(10, 20, 5) # ❌ 报错 🧩 四、在调用函数时使用 * / ** —— 参数「解包」 这时 * / ** 的作用是 把序列或字典拆包成参数列表。\n示例 1：解包列表或元组 1 2 3 4 5 def add(a, b, c): print(a + b + c) nums = [1, 2, 3] add(*nums) # 等价于 add(1, 2, 3) 示例 2：解包字典 1 2 3 4 5 def print_person(name, age): print(name, age) person = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 25} print_person(**person) # 等价于 print_person(name=\u0026#34;Alice\u0026#34;, age=25) 🧩 五、总结对比表 形式 定义中含义 调用中含义 *args 收集多个位置参数为元组 解包序列为多个位置参数 **kwargs 收集多个关键字参数为字典 解包字典为多个关键字参数 单独 * 限制后续参数必须用关键字 ——（不能单独在调用中使用） ✅ 一句话总结：\n* → 打包或解包“位置参数”； ** → 打包或解包“关键字参数”； 单独的 * → 标识“后面参数必须用关键字传入”。\n","date":"2025-10-28T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/xinghaoinpy/","title":"Python中*"},{"content":"\n简介 中间件（Middleware） 是 ASP.NET Core 的核心组件，用于处理 HTTP 请求和响应的管道机制。它是基于管道模型的轻量级、模块化设计，允许开发者在请求处理过程中插入自定义逻辑。中间件广泛应用于日志记录、认证授权、异常处理、路由等场景。\n定义：中间件是处理 HTTP 请求和响应的组件，位于服务器接收到请求到最终返回响应之间的“管道”中。 作用：可用于身份认证、授权、日志、静态文件、异常处理、CORS、压缩、路由等横切关注点。 职责链：请求依次经过每个中间件，执行“前置逻辑”→调用下一个中间件→执行“后置逻辑”，最终形成责任链。 请求管道（Request Pipeline） 构建：在 Startup.Configure(IApplicationBuilder app) 中，通过 app.UseXXX()、app.Run() 等方法，按注册顺序构建一条 RequestDelegate 链。 执行：框架在收到 HTTP 请求时，从管道头部（第一个中间件）开始执行，直到找到终结点（UseEndpoints/Run）或管道结束。 短路：中间件可以选择不调用 next()，直接生成响应，阻断后续中间件。 请求流程：Client → Middleware1 → Middleware2 → \u0026hellip; → Endpoint 响应流程：Endpoint → \u0026hellip; → Middleware2 → Middleware1 → Client 1 2 3 HTTP → [Middleware A] → [Middleware B] → [Middleware C] → Response ↑ ↓ 前置逻辑 A 后置逻辑 B 请求委托（RequestDelegate） 每个中间件通过 RequestDelegate 封装处理逻辑，接收 HttpContext 并异步执行操作\n1 2 3 4 5 6 public async Task InvokeAsync(HttpContext context, RequestDelegate next) { // 预处理请求 await next(context); // 调用下一个中间件 // 后处理响应 } 短路（Short-Circuiting） 中间件可通过不调用 next() 终止管道，直接返回响应（如静态文件中间件找到文件时）\n中间件的注册与类型 注册方式 通过 IApplicationBuilder 在 Program.cs 或 Startup.Configure 中注册，顺序决定执行优先级\n方法 方法 示例 Use 添加可调用下一个中间件的组件 app.Use(async (ctx, next) =\u0026gt; { ... await next(); ... }) Run 添加终端中间件（强制短路） app.Run(ctx =\u0026gt; ctx.Response.WriteAsync(\u0026quot;End\u0026quot;)) Map 根据路径分支管道 app.Map(\u0026quot;/admin\u0026quot;, branch =\u0026gt; { ... }) MapWhen 按条件分支管道 app.MapWhen(ctx =\u0026gt; ctx.Request.Query.ContainsKey(\u0026quot;log\u0026quot;), branch =\u0026gt; ...) 生命周期管理 单例构造：中间件类在应用启动时实例化（构造函数仅执行一次） 按请求执行：Invoke 或 InvokeAsync 方法对每个请求调用一次 自定义中间件实现 基本模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class MyMiddleware { private readonly RequestDelegate _next; public MyMiddleware(RequestDelegate next) { _next = next; } public async Task InvokeAsync(HttpContext context) { // 前置逻辑 // e.g. 日志：Console.WriteLine(\u0026#34;Request start: \u0026#34; + context.Request.Path); await _next(context); // 调用下一个中间件 // 后置逻辑 // e.g. 日志：Console.WriteLine(\u0026#34;Request end: \u0026#34; + context.Response.StatusCode); } } 扩展方法 1 2 3 4 5 6 7 public static class MyMiddlewareExtensions { public static IApplicationBuilder UseMyMiddleware(this IApplicationBuilder app) { return app.UseMiddleware\u0026lt;MyMiddleware\u0026gt;(); } } 在 Startup.Configure 或 Program 中调用：\n1 app.UseMyMiddleware(); 内置中间件概览 中间件 功能 UseRouting / UseEndpoints 路由匹配与终结点执行 UseStaticFiles 提供静态文件服务 UseAuthentication 验证用户身份 UseAuthorization 授权策略检查 UseCors 跨域请求支持 UseResponseCompression 响应内容压缩 UseSession 会话状态管理 UseExceptionHandler / UseDeveloperExceptionPage 全局异常捕获与开发环境错误页 UseHttpsRedirection HTTP 自动重定向到 HTTPS UseForwardedHeaders X-Forwarded-For / X-Forwarded-Proto 处理 典型的注册顺序：\n1 2 3 4 5 6 7 8 9 app.UseExceptionHandler(\u0026#34;/Error\u0026#34;); // 异常处理（最先） app.UseHttpsRedirection(); // HTTPS 重定向 app.UseStaticFiles(); // 静态文件 app.UseRouting(); // 路由 app.UseAuthentication(); // 认证 app.UseAuthorization(); // 授权 app.UseEndpoints(endpoints =\u0026gt; { // 端点处理（最后） endpoints.MapControllers(); }); 注册顺序与注意事项 异常处理：\nUseDeveloperExceptionPage（开发环境）或 UseExceptionHandler 应放在最前面，捕获后续所有异常。 HTTPS 重定向：\nUseHttpsRedirection 需在路由、静态文件之前。 静态文件：\n若站点静态资源较多，应尽早调用 UseStaticFiles，避免无谓路由匹配。 路由与终结点：\n必须在 UseRouting 后调用 UseAuthentication/UseAuthorization，再调用 UseEndpoints。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) app.UseDeveloperExceptionPage(); else app.UseExceptionHandler(\u0026#34;/Home/Error\u0026#34;); app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers(); endpoints.MapRazorPages(); }); } 终结点与分支 终结点（Endpoint）：UseEndpoints 中注册具体的请求处理，如 MVC 控制器、Razor 页面、SignalR、gRPC。\n分支管道：app.Map(\u0026quot;/path\u0026quot;, branch =\u0026gt; { /* branch.UseXXX() */ });\n根据路径或条件，将请求“分流”到不同的子管道。 1 2 3 4 5 6 app.Map(\u0026#34;/api\u0026#34;, apiApp =\u0026gt; { apiApp.UseRouting(); apiApp.UseAuthorization(); apiApp.UseEndpoints(endpoints =\u0026gt; endpoints.MapControllers()); }); 进阶用法 条件执行 1 2 3 4 app.UseWhen(ctx =\u0026gt; ctx.Request.Path.StartsWithSegments(\u0026#34;/mobile\u0026#34;), mobileApp =\u0026gt; { mobileApp.UseMiddleware\u0026lt;MobileSpecificMiddleware\u0026gt;(); }); 中间件短路 1 2 3 4 5 6 7 8 9 10 11 app.Use(async (ctx, next) =\u0026gt; { if (ctx.Request.Path == \u0026#34;/health\u0026#34;) { ctx.Response.StatusCode = 200; await ctx.Response.WriteAsync(\u0026#34;OK\u0026#34;); return; // 不调用 next，直接返回 } await next(); }); 捕获并处理异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ErrorHandlingMiddleware { private readonly RequestDelegate _next; public ErrorHandlingMiddleware(RequestDelegate next) =\u0026gt; _next = next; public async Task InvokeAsync(HttpContext ctx) { try { await _next(ctx); } catch (Exception ex) { ctx.Response.StatusCode = 500; await ctx.Response.WriteAsync(\u0026#34;Internal Server Error\u0026#34;); // TODO: 日志记录 ex } } } 分支中间件（Map/MapWhen） 1 2 3 4 5 6 7 8 9 10 11 12 // 基于路径分支 app.Map(\u0026#34;/api\u0026#34;, apiApp =\u0026gt; { apiApp.UseAuthentication(); apiApp.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers(); }); }); // 基于条件分支 app.MapWhen(context =\u0026gt; context.Request.Query.ContainsKey(\u0026#34;debug\u0026#34;), debugApp =\u0026gt; { debugApp.UseMiddleware\u0026lt;DebugLoggingMiddleware\u0026gt;(); }); 终结点中间件（Run） 1 2 3 4 // 直接终止请求管道，不调用后续中间件 app.Run(async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Hello from terminal middleware!\u0026#34;); }); 中间件与依赖注入一 在中间件中使用服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class AuthenticationMiddleware { private readonly RequestDelegate _next; private readonly IAuthService _authService; public AuthenticationMiddleware(RequestDelegate next, IAuthService authService) { _next = next; _authService = authService; } public async Task InvokeAsync(HttpContext context) { var token = context.Request.Headers[\u0026#34;Authorization\u0026#34;]; var user = await _authService.ValidateToken(token); context.User = user; await _next(context); } } 作用域服务注入 1 2 3 4 5 6 7 8 9 public async Task InvokeAsync(HttpContext context) { // 手动解析作用域服务 using (var scope = context.RequestServices.CreateScope()) { var scopedService = scope.ServiceProvider.GetRequiredService\u0026lt;IScopedService\u0026gt;(); await scopedService.ProcessRequest(context); } await _next(context); } 带配置的中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class CustomHeaderMiddleware { private readonly RequestDelegate _next; private readonly string _headerValue; public CustomHeaderMiddleware( RequestDelegate next, string headerValue) // 配置参数 { _next = next; _headerValue = headerValue; } public async Task Invoke(HttpContext context) { context.Response.Headers[\u0026#34;X-Custom\u0026#34;] = _headerValue; await _next(context); } } // 注册时传递配置 app.UseMiddleware\u0026lt;CustomHeaderMiddleware\u0026gt;(\u0026#34;MyValue\u0026#34;); 中间件工厂 (IMiddlewareFactory) 1 2 3 4 5 6 7 8 9 10 11 12 public class CustomMiddlewareFactory : IMiddlewareFactory { public IMiddleware Create(Type middlewareType) { return ActivatorUtilities.CreateInstance(_serviceProvider, middlewareType) as IMiddleware; } public void Release(IMiddleware middleware) =\u0026gt; (middleware as IDisposable)?.Dispose(); } // 注册工厂 builder.Services.AddSingleton\u0026lt;IMiddlewareFactory, CustomMiddlewareFactory\u0026gt;(); 中间件依赖注入二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class MyMiddleware { private readonly RequestDelegate _next; private readonly IUserService _userService; public MyMiddleware(RequestDelegate next, IUserService userService) { _next = next; _userService = userService; } public async Task InvokeAsync(HttpContext context) { var userName = _userService.GetUserName(1); await context.Response.WriteAsync($\u0026#34;User: {userName}\u0026#34;); await _next(context); } } public static class MyMiddlewareExtensions { public static IApplicationBuilder UseMyMiddleware(this IApplicationBuilder builder) { return builder.UseMiddleware\u0026lt;MyMiddleware\u0026gt;(); } } // 注册服务 builder.Services.AddScoped\u0026lt;IUserService, UserService\u0026gt;(); app.UseMyMiddleware(); 内置中间件 内置中间件 1 2 3 4 5 6 7 8 app.UseRouting(); // 路由匹配 app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapControllers(); // API控制器 endpoints.MapRazorPages(); // Razor页面 endpoints.MapHub\u0026lt;ChatHub\u0026gt;(\u0026#34;/chat\u0026#34;); // SignalR }); 异常处理中间件 1 2 3 4 5 6 7 8 9 10 11 12 app.UseExceptionHandler(errorApp =\u0026gt; { errorApp.Run(async context =\u0026gt; { var exceptionHandler = context.Features.Get\u0026lt;IExceptionHandlerFeature\u0026gt;(); // 记录异常 await context.Response.WriteAsJsonAsync(new { Error = exceptionHandler.Error.Message }); }); }); 静态文件中间件 1 2 3 4 5 6 7 8 9 10 app.UseStaticFiles(new StaticFileOptions { FileProvider = new PhysicalFileProvider( Path.Combine(builder.Environment.ContentRootPath, \u0026#34;Assets\u0026#34;)), RequestPath = \u0026#34;/static\u0026#34;, OnPrepareResponse = ctx =\u0026gt; { ctx.Context.Response.Headers.Append(\u0026#34;Cache-Control\u0026#34;, \u0026#34;public,max-age=3600\u0026#34;); } }); ","date":"2025-10-27T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/middleware/","title":"C#.NET 中间件详解"},{"content":"在使用 RestSharp 时，很多人会遇到一个常见问题：序列化成 JSON 时字段的大小写被改变（比如属性名变成小写或 camelCase）。这通常与 RestSharp 默认使用的 JSON 序列化器（System.Text.Json 或 Newtonsoft.Json） 有关。\n序列化器 默认属性命名策略 结果示例 说明 关闭大小写变化的方法 System.Text.Json (.NET Core 3+ 默认) ✅ camelCase（首字母小写） UserName → userName 更符合前端 JavaScript 习惯 options.PropertyNamingPolicy = null Newtonsoft.Json (Json.NET) ❌ 保留原有大小写 UserName → UserName 更传统，更适合后端系统间通信 ContractResolver = new DefaultContractResolver() ","date":"2025-10-11T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/serializationinrestsharp/","title":"System.Text.Json 和 Newtonsoft.Json 默认序列化时的大小写行为差异"},{"content":"📌 引言：async/await 很强大，但也很容易用错！ 在 .NET 中使用 async 和 await 进行异步编程，确实让代码看起来更简洁、逻辑更清晰。但正因为写起来太“顺手”，很多开发者（包括我自己）都曾不小心掉进过各种“坑”里。\n比如程序卡死、性能下降、异常丢失、资源耗尽……这些问题往往不是语法错误造成的，而是对异步机制的理解不到位。\n今天我就来总结一下，.NET 开发者最容易犯的 6 个 async/await 使用错误，并告诉你正确的做法是什么。希望你看了之后能少走弯路，写出真正高效又稳定的异步代码。\n🔥 常见错误一：用了 .Result 或 .Wait() 阻塞异步方法 ❌ 错误示例： 1 var result = GetDataAsync().Result; 或者：\n1 GetDataAsync().Wait(); ⚠️ 为什么有问题？ 这看似只是等一个结果，但在某些上下文环境中（比如 UI 线程或 ASP.NET 请求线程），这样做会导致死锁！\n原因在于：\nawait 默认会尝试回到原来的上下文线程去继续执行。 如果主线程被 .Result 或 .Wait() 阻塞了，就没人去释放它，导致死循环。 ✅ 正确做法： 如果当前方法支持异步，就把它也标记为 async，然后用 await：\n1 var result = await GetDataAsync(); 💡 小贴士： ★\n在 ASP.NET Core、WPF、WinForms、Blazor Server 这类框架中，一定要避免使用 .Result 或 .Wait()，否则很容易引发死锁问题。\n🔥 常见错误二：写了 async 方法，却没用 await ❌ 错误示例： 1 2 3 4 public async Task DoWorkAsync() { Task.Delay(1000); // 啥也没干 } ⚠️ 有什么问题？ 这个方法虽然加了 async，但没有用 await，所以它其实是一个同步方法，只不过多了一个状态机包装而已。\n更糟的是，编译器并不会报错，你可能还以为自己写了个异步方法。\n✅ 正确做法： 要用 await 才能真正进入异步流程：\n1 2 3 4 public async Task DoWorkAsync() { await Task.Delay(1000); } 💡 小贴士： ★\n每一个 async 方法都应该至少有一个 await；如果没有，那就不应该加 async。\n🔥 常见错误三：使用 async void（除了事件处理） ❌ 错误示例： 1 2 3 4 public async void SaveDataAsync() { await Task.Delay(500); } ⚠️ 为什么危险？ async void 方法就像“幽灵”一样，你无法等待它完成，也无法捕获它的异常。\n一旦抛出异常，就会直接崩溃整个应用程序 —— 即使你在外面写了 try-catch 也没用！\n✅ 正确做法： 除非是事件处理函数（比如按钮点击），否则一律返回 Task：\n1 2 3 4 public async Task SaveDataAsync() { await Task.Delay(500); } 这样就可以被 await 调用，并且能正确处理异常。\n💡 小贴士： ★\n除了事件处理器，永远不要写 async void 方法。它就像是“裸奔”的异步方法，非常不安全。\n🔥 常见错误四：明明不需要异步，却还加 async ❌ 错误示例： 1 2 3 4 public async Task\u0026lt;int\u0026gt; GetNumberAsync() { return 42; } ⚠️ 有什么问题？ 这个方法根本没有做任何异步操作，但却加了 async 关键字，白白引入了状态机，增加了性能开销。\n这不是“为了异步而异步”，而是“为了装样子而异步”。\n✅ 正确做法： 如果你的方法就是同步返回数据，那就不要用 async，直接返回已完成的 Task：\n1 2 3 4 public Task\u0026lt;int\u0026gt; GetNumberAsync() { return Task.FromResult(42); } 💡 小贴士： ★\n只有当你真的在调用 I/O、数据库、网络请求等异步操作时，才需要用 async/await，否则就别滥用。\n🔥 常见错误五：每次调用都 new HttpClient ❌ 错误示例： 1 2 3 4 5 public async Task\u0026lt;string\u0026gt; GetData() { using var client = new HttpClient(); // 每次都新建一个 return await client.GetStringAsync(\u0026#34;https://api.example.com/data\u0026#34;); } ⚠️ 有什么风险？ 每次创建 HttpClient 实际上都会打开一个新的 TCP 连接，而且关闭后不会立刻释放端口，容易造成端口耗尽（Socket Exhaustion）。\n尤其是在高并发场景下，这种写法可能会让你的应用突然“挂掉”。\n✅ 正确做法： 把 HttpClient 当作共享资源来使用，推荐通过依赖注入的方式获取：\n1 2 3 4 5 6 7 8 9 10 11 private readonly HttpClient _httpClient; public MyService(HttpClient httpClient) { _httpClient = httpClient; } public async Task\u0026lt;string\u0026gt; GetData() { return await _httpClient.GetStringAsync(\u0026#34;https://api.example.com/data\u0026#34;); } 这样不仅复用了连接，还能更好地控制生命周期。\n💡 小贴士： ★\nHttpClient 是设计用来长期使用的，频繁 new 它是一种“反模式”。建议配合 IHttpClientFactory 或服务注入一起使用。\n🔥 常见错误六：忽略 ConfigureAwait(false)，导致上下文捕获引发死锁 ❌ 错误示例： 1 2 3 4 5 // 默认捕获当前上下文，可能导致线程阻塞 public async Task DoWorkAsync() { await SomeIoOperationAsync(); // 默认会尝试回到原始上下文 } ⚠️ 有什么问题？ 在很多异步库或框架中（如 ASP.NET 或 WPF），await 默认会尝试捕获当前的同步上下文（Synchronization Context），并在任务完成后回到这个上下文继续执行后续代码。\n这在 UI 应用中是有意义的，但在非 UI 层（如类库、服务层）中，这种行为反而可能带来不必要的性能开销，甚至在某些情况下引发死锁。\n✅ 正确做法： 在非 UI 代码中，建议加上 .ConfigureAwait(false) 来避免上下文捕获：\n1 2 3 4 5 // 避免上下文捕获，提高性能并防止死锁 public async Task DoWorkAsync() { await SomeIoOperationAsync().ConfigureAwait(false); } 💡 小贴士： ★\n在类库、通用方法、后台服务中，建议始终加上 .ConfigureAwait(false)，除非你确实需要回到原始上下文。\n🧾 总结：async/await 的最佳实践清单 问题 推荐做法 ❌ 使用 .Result 或 .Wait() ✅ 改成 async/await，保持异步链 ❌ 写了 async 却不用 await ✅ 该删就删，不该加就别加 ❌ 乱用 async void ✅ 仅限事件处理，其他一律用 Task ❌ 不需要异步却加了 async ✅ 用 Task.FromResult() 替代 ❌ 每次都 new HttpClient ✅ 全局复用或通过 DI 获取 ❌ 忽略 ConfigureAwait(false) ✅ 非 UI 代码中加上 .ConfigureAwait(false) 🎯 写在最后 async/await 是 .NET 中非常强大的工具，但也是一把双刃剑。用得好，能让你的应用响应更快、吞吐更高；用不好，轻则性能下降，重则系统崩溃。\n这篇文章列出的六个常见错误，都是我们在实际项目中最容易踩到的“地雷”。希望你能从中吸取经验教训，写出更稳定、更高效的异步代码。\n","date":"2025-07-15T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/asyncawait/","title":"最容易踩坑的6个async/await 使用错误"},{"content":"某些数据库（尤其是 SQL Server）对形成周期的级联行为有限制。 例如，请考虑以下模型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Blog { public int Id { get; set; } public string Name { get; set; } public IList\u0026lt;Post\u0026gt; Posts { get; } = new List\u0026lt;Post\u0026gt;(); public int OwnerId { get; set; } public Person Owner { get; set; } } public class Post { public int Id { get; set; } public string Title { get; set; } public string Content { get; set; } public int BlogId { get; set; } public Blog Blog { get; set; } public int AuthorId { get; set; } public Person Author { get; set; } } public class Person { public int Id { get; set; } public string Name { get; set; } public IList\u0026lt;Post\u0026gt; Posts { get; } = new List\u0026lt;Post\u0026gt;(); public Blog OwnedBlog { get; set; } } 此模型具有三种关系，全部必需，因此配置为按约定级联删除：\n删除博客将同时删除所有相关帖子 删除帖子的作者将导致其创作的帖子被级联删除。 删除博客所有者将导致博客被级联删除 这一切都是合理的（虽然博客管理策略有些严厉！），但尝试配置这些级联来创建 SQL Server 数据库会引发以下异常：\nMicrosoft.Data.SqlClient.SqlException （0x80131904）：在表“Post”上引入 FOREIGN KEY 约束“FK_Posts_Person_AuthorId”可能会导致循环或多个级联路径。 请指定 ON DELETE NO ACTION 或 ON UPDATE NO ACTION，或修改其他 FOREIGN KEY 约束。\n有两种方法可以处理这种情况：\n更改一个或多个关系以使其不进行级联删除。 在没有一个或多个此类级联删除的情况下配置数据库，然后确保加载所有依赖实体，以便 EF Core 可以执行级联行为。 通过示例采用第一种方法，我们可以通过为其提供可为 null 的外键属性来使博客后的关系可选：\n1 public int? BlogId { get; set; } 可选关系允许帖子在没有博客的情况下存在，这意味着默认情况下将不再配置级联删除。 这意味着在级联作中不再存在循环，可以在 SQL Server 上创建数据库而不出错。\n改用第二种方法，我们可以保留博客与所有者的关系，并配置为级联删除，但使此配置仅适用于被跟踪的实体，而不是整个数据库。\n1 2 3 4 5 6 7 8 protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder .Entity\u0026lt;Blog\u0026gt;() .HasOne(e =\u0026gt; e.Owner) .WithOne(e =\u0026gt; e.OwnedBlog) .OnDelete(DeleteBehavior.ClientCascade); } 现在，如果我们同时加载一个人和他们拥有的博客，那么会发生什么情况，然后删除该人员？\n1 2 3 4 5 6 7 8 using var context = new BlogsContext(); var owner = await context.People.SingleAsync(e =\u0026gt; e.Name == \u0026#34;ajcvickers\u0026#34;); var blog = await context.Blogs.SingleAsync(e =\u0026gt; e.Owner == owner); context.Remove(owner); await context.SaveChangesAsync(); EF Core 将级联删除所有者，以便同时删除博客：\n1 2 3 4 5 6 7 8 9 10 11 -- Executed DbCommand (8ms) [Parameters=[@p0=\u0026#39;1\u0026#39;], CommandType=\u0026#39;Text\u0026#39;, CommandTimeout=\u0026#39;30\u0026#39;] SET NOCOUNT ON; DELETE FROM [Blogs] WHERE [Id] = @p0; SELECT @@ROWCOUNT; -- Executed DbCommand (2ms) [Parameters=[@p1=\u0026#39;1\u0026#39;], CommandType=\u0026#39;Text\u0026#39;, CommandTimeout=\u0026#39;30\u0026#39;] SET NOCOUNT ON; DELETE FROM [People] WHERE [Id] = @p1; SELECT @@ROWCOUNT; 但是，如果在删除所有者时博客未加载：\n1 2 3 4 5 6 7 using var context = new BlogsContext(); var owner = await context.People.SingleAsync(e =\u0026gt; e.Name == \u0026#34;ajcvickers\u0026#34;); context.Remove(owner); await context.SaveChangesAsync(); 然后，由于违反数据库中的外键约束，将引发异常：\nMicrosoft.Data.SqlClient.SqlException：DELETE 语句与 REFERENCE 约束“FK_Blogs_People_OwnerId”冲突。 数据库“Scratch”中表“dbo.Blogs”的列“OwnerId”发生冲突。 语句已终止。\n","date":"2025-07-10T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/ef-core-cascade-delete/","title":"数据库级联限制"},{"content":"当谈及计算机中的数据时，我们会想到文本、图片、视频、语音、3D 模型等各种形式。尽管这些数据的组织形式各异，但它们都由各种基本数据类型构成。\n基本数据类型是 CPU 可以直接进行运算的类型，在算法中直接被使用，主要包括以下几种。\n整数类型 byte、short、int、long 。 浮点数类型 float、double ，用于表示小数。 字符类型 char ，用于表示各种语言的字母、标点符号甚至表情符号等。 布尔类型 bool ，用于表示“是”与“否”判断。 基本数据类型以二进制的形式存储在计算机中。一个二进制位即为1 比特。在绝大多数现代操作系统中，1 字节（byte）由8 比特（bit）组成。\n基本数据类型的取值范围取决于其占用的空间大小。下面以 Java 为例。\n整数类型 byte 占用1 字节 =8 比特 ，可以表示28 个数字。 整数类型 int 占用4 字节 =32 比特 ，可以表示232 个数字。 表 3-1 列举了 Java 中各种基本数据类型的占用空间、取值范围和默认值。此表格无须死记硬背，大致理解即可，需要时可以通过查表来回忆。\n表 3-1 \u0026nbsp; 基本数据类型的占用空间和取值范围 类型 符号 占用空间 最小值 最大值 默认值 整数 byte 1 字节 $-2^7$ ($-128$) $2^7 - 1$ ($127$) $0$ short 2 字节 $-2^{15}$ $2^{15} - 1$ $0$ int 4 字节 $-2^{31}$ $2^{31} - 1$ $0$ long 8 字节 $-2^{63}$ $2^{63} - 1$ $0$ 浮点数 float 4 字节 $1.175 \\times 10^{-38}$ $3.403 \\times 10^{38}$ $0.0\\text{f}$ double 8 字节 $2.225 \\times 10^{-308}$ $1.798 \\times 10^{308}$ $0.0$ 字符 char 2 字节 $0$ $2^{16} - 1$ $0$ 布尔 bool 1 字节 $\\text{false}$ $\\text{true}$ $\\text{false}$ 请注意，表 3-1 针对的是 Java 的基本数据类型的情况。每种编程语言都有各自的数据类型定义，它们的占用空间、取值范围和默认值可能会有所不同。\n在 Python 中，整数类型 int 可以是任意大小，只受限于可用内存；浮点数 float 是双精度 64 位；没有 char 类型，单个字符实际上是长度为 1 的字符串 str 。\nC 和 C++ 未明确规定基本数据类型的大小，而因实现和平台各异。表 3-1 遵循 LP64 数据模型，其用于包括 Linux 和 macOS 在内的 Unix 64 位操作系统。\n字符 char 的大小在 C 和 C++ 中为 1 字节，在大多数编程语言中取决于特定的字符编码方法，详见“字符编码”章节。\n即使表示布尔量仅需 1 位（\n0 或\n1），它在内存中通常也存储为 1 字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。\n那么，基本数据类型与数据结构之间有什么联系呢？我们知道，数据结构是在计算机中组织与存储数据的方式。这句话的主语是“结构”而非“数据”。\n如果想表示“一排数字”，我们自然会想到使用数组。这是因为数组的线性结构可以表示数字的相邻关系和顺序关系，但至于存储的内容是整数 int、小数 float 还是字符 char ，则与“数据结构”无关。\n换句话说，基本数据类型提供了数据的“内容类型”，而数据结构提供了数据的“组织方式”。例如以下代码，我们用相同的数据结构（数组）来存储与表示不同的基本数据类型，包括 int、float、char、bool 等。\n","date":"2025-06-25T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/basic_data_types/","title":"基本数据类型"},{"content":"使用 EventWaitHandle 原理：通过命名的事件对象（EventWaitHandle）检测是否已有实例运行。\n特点：\n适合跨进程通信（IPC）。 可以通过 Set() 和 WaitOne() 唤醒其他实例（如你的代码中唤醒主窗口）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 public bool EnsureAppSingletion() { EventWaitHandle singletonEvent = new EventWaitHandle(false, EventResetMode.AutoReset, \u0026#34;SlimeNull/OpenGptChat\u0026#34;, out bool createdNew); if (createdNew) { Task.Run(() =\u0026gt; { while (true) { // wait for the second instance of OpenGptChat singletonEvent.WaitOne(); Dispatcher.Invoke(() =\u0026gt; { ShowApp(); }); } }); return true; } else { singletonEvent.Set(); return false; } } public static void ShowApp() { Window mainWindow = Application.Current.MainWindow; if (mainWindow == null) return; mainWindow.Show(); if (mainWindow.WindowState == WindowState.Minimized) mainWindow.WindowState = WindowState.Normal; if (!mainWindow.IsActive) mainWindow.Activate(); } public bool EnsureAppSingletion() { EventWaitHandle singletonEvent = new EventWaitHandle(false, EventResetMode.AutoReset, \u0026#34;SlimeNull/OpenGptChat\u0026#34;, out bool createdNew); if (createdNew) { Task.Run(() =\u0026gt; { while (true) { // wait for the second instance of OpenGptChat singletonEvent.WaitOne(); Dispatcher.Invoke(() =\u0026gt; { ShowApp(); }); } }); return true; } else { singletonEvent.Set(); return false; } } public static void ShowApp() { Window mainWindow = Application.Current.MainWindow; if (mainWindow == null) return; mainWindow.Show(); if (mainWindow.WindowState == WindowState.Minimized) mainWindow.WindowState = WindowState.Normal; if (!mainWindow.IsActive) mainWindow.Activate(); } 使用 Mutex（互斥锁） 原理：通过命名的互斥锁检测是否已有实例运行。 特点： 更轻量级，适合单纯判断单例（不涉及复杂通信）。 系统会自动释放资源（Mutex 继承自 WaitHandle，有 Dispose() 机制）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public bool EnsureAppSingleton() { bool isFirstInstance; Mutex mutex = new Mutex(true, \u0026#34;SlimeNull/OpenGptChat\u0026#34;, out isFirstInstance); if (isFirstInstance) { // 首次运行，保持 Mutex 不释放（通过不调用 ReleaseMutex） return true; } else { mutex.Dispose(); // 立即释放资源 return false; } } public bool EnsureAppSingleton() { bool isFirstInstance; Mutex mutex = new Mutex(true, \u0026#34;SlimeNull/OpenGptChat\u0026#34;, out isFirstInstance); if (isFirstInstance) { // 首次运行，保持 Mutex 不释放（通过不调用 ReleaseMutex） return true; } else { mutex.Dispose(); // 立即释放资源 return false; } } 两种方式的对比 特性 EventWaitHandle Mutex 主要用途 跨进程通信 + 单例判断 单例判断（轻量级） 资源释放 需手动 Dispose() 或 Close() 自动释放（using 语句） 唤醒其他实例 支持（通过 Set()） 不支持 性能 稍重（适合复杂场景） 更轻量 如何选择？ 如果只需要判断单例（不涉及唤醒其他实例），优先用 Mutex（代码更简洁）。 如果需要唤醒已有实例（如你的代码中唤醒主窗口），用 EventWaitHandle。 ","date":"2025-06-19T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E5%8D%95%E4%BE%8B/","title":"Windows桌面程序单例"},{"content":"基础知识 光学：几何光学，物理光学\n数学：导数为主的高等数学，矩阵论\n五种需求： 1.识别定位\n2.符号识别：一二维码，OCR\n3.测量需求\n4.缺陷需求（最常见，难度最大）\n5.手眼标定和抓取（结合运动控制）\n图像处理一般思路 1.采集\n2.预处理\n拉开灰度 几何变换 去噪：中值滤波，均值滤波，高斯滤波 抠图 3.图像分割\n二值化 形态学 特征选择 ps：Halcon里区域和图像是不同概念\n4.识别显示\n5.通信\n三大数据类型 图像，区域，XLD\n灰度直方图 勾选“阈值”\n将灰度值在”绿线和红线之间”的以选定颜色进行填充 勾选“缩放”\n将把圈定的阈值范围内的直方图均匀拉伸释放到整个直方图轴上 数组语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 * Simple tuple operations Tuple1 := [1,2,3,4,5] Number := |Tuple1| SingleElement := Tuple1[3] Part := Tuple1[1:3] Copy := Tuple1[0:|Tuple1| - 1] * Simple tuple operations Tuple1 := [1,2,3,4,5] Number := |Tuple1| SingleElement := Tuple1[3] Part := Tuple1[1:3] Copy := Tuple1[0:|Tuple1| - 1] 运行结果 读取图片的四种方法 文件 -\u0026gt; 读取图片\nImage Acquisition -\u0026gt; 自动检测接口（刷新设备）-\u0026gt; Direct show，从摄像头直接读图\nImage Acquisition -\u0026gt; 选择文件，从图像文件中读取\nImage Acquisition -\u0026gt; 选择路径，结合正则表达式读取路径下的图片\nPS：用Image Acquisition读取时记得点击代码生成 摄像头抓取模式：在可视化 -\u0026gt; 更新窗口中调整\n同步采集：实时抓取，一直抓取\n异步采集：只等图片处理完后，grab_image才开始抓取\nPS：更多信息包括双相机采集，可以在案例 -\u0026gt; 方法 -\u0026gt; 图像采集设备中学习\nROI（感兴趣区域） 特征检测 PS：二值化之后的区域虽然不连通，但仍然认为是一个区域。需要调用connection把区域分割成独立区域，才能进行select_shape，点击特定区域，再进行特征检测，则显示特定区域的特征信息。（connection分割依据（九宫格中的八邻域））\n若直方图窗口内的直方图不显示\n1.将程序执行一遍（按完全执行或F5）\n2.将直方图窗口纵向拉大（这个拉升方案默认把剩余显示区域留给直方图）\n形态学 膨胀：\n将模板在原图上移动，当除中心点外的模板点，与原图中像素重合时，将中心点变黑。最终结果（当然也能覆盖原图）就是新图 效果即扩大了“一圈” 腐蚀：\n将模板在原图上移动，仅有整个结构元素能全部被区域所包含时，保留中心元素点，最终结果即新图能被原图包含 效果即缩小了“一圈” 开运算：\n先腐蚀，后膨胀 效果：减少像素（弱于腐蚀），断开 闭运算：\n先膨胀，后腐蚀 效果：增加像素（弱于膨胀），连接 PS：以上是对二值图像而言，而对灰度图像做形态学处理是改变亮暗\n代码运行事件监测 使用count函数 如图使用“性能评测器” 结构元素模板选择 要根据感兴趣的图像结构 来灵活选择结构元素模板 效果展示(以官方例程ball.hdve为例)：\n原图 红色-\u0026gt;圆结构元素提取 绿色-\u0026gt;矩形结构提取 可以知道，想要提取圆的时候，采用圆结构元素能更好保留形态\n之后采用圆度特征进行进一步的blob提取\n预处理图像增强 一般通过如下几种方式：\nscale_image: g’ := g * Mult + Add\ng为当前的灰度值，Mult 为所乘的系数，Add为加的偏移值，由公式可以刊出用scale_image来处理图像是个线性变化，会让黑的地方更黑，亮的地方更亮。\n图像形态学\ngray_opening\n结构元素在图像中滑，灰度值最高的值作为新值，有使图像变亮的作用。\ngray_closing\n结构元素在图像中滑，灰度值最低的值作为新值，有使图像变暗的作用。\ngray_range_rect\n用一个矩形结构元素在图像中滑动，新值=(矩形中最大的)灰度值-(矩形中最大的)最小的灰度值\nemphasize: res := round((orig - mean) * Factor) + orig\nmean代表先对原图进行mean_image后的图像对应的灰度值，\norig 代表每幅图对应的灰阶值 ，res代表输出图像的灰阶值\n凸性 凸性：图形内任意两点相连，图像上所有的点相连的的线进行点填充 1 函数：shape_trans(Region, RegionTrans, \u0026#39;convex\u0026#39;) 外接矩形：不赘述 1 函数：shape_trans(Region, RegionTrans, \u0026#39;rectangle1\u0026#39;) PS：rectangle1为平行于窗口的正矩形，rectangle2为斜外接矩形，详见官方手册\n以下图为例，凸形和外接矩形分别如下\n定位方法 Blob分析 模板匹配 通过mark点或特征找出兴趣区域 仿射变换到标准位置 仿射变换 以官方例程check_blister.hdev介绍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 dev_update_window (\u0026#39;off\u0026#39;) //停止更新窗体 dev_close_window () //关闭窗体 read_image (ImageOrig, \u0026#39;blister/blister_reference\u0026#39;) dev_open_window_fit_image (ImageOrig, 0, 0, -1, -1, WindowHandle) //窗口大小适应图片 access_channel (ImageOrig, Image1, 1) //通道1，R图 threshold (Image1, Region, 90, 255) //二值化，灰度直方图工具 shape_trans (Region, Blister, \u0026#39;convex\u0026#39;) //凸包，内部都被填充 orientation_region (Blister, Phi) //区域方向，获得角度值Phi，范围[-Π,Π) area_center (Blister, Area1, Row, Column) //获得面积、质心坐标 vector_angle_to_rigid (Row, Column, Phi, Row, Column, 0, HomMat2D) // 获得仿射变换矩阵HomMat2D affine_trans_image (ImageOrig, Image2, HomMat2D, \u0026#39;constant\u0026#39;, \u0026#39;false\u0026#39;) //对图像进行仿射变换，插值算法constant dev_update_window (\u0026#39;on\u0026#39;) //更新窗体 dev_update_window (\u0026#39;off\u0026#39;) //停止更新窗体 dev_close_window () //关闭窗体 read_image (ImageOrig, \u0026#39;blister/blister_reference\u0026#39;) dev_open_window_fit_image (ImageOrig, 0, 0, -1, -1, WindowHandle) //窗口大小适应图片 access_channel (ImageOrig, Image1, 1) //通道1，R图 threshold (Image1, Region, 90, 255) //二值化，灰度直方图工具 shape_trans (Region, Blister, \u0026#39;convex\u0026#39;) //凸包，内部都被填充 orientation_region (Blister, Phi) //区域方向，获得角度值Phi，范围[-Π,Π) area_center (Blister, Area1, Row, Column) //获得面积、质心坐标 vector_angle_to_rigid (Row, Column, Phi, Row, Column, 0, HomMat2D) // 获得仿射变换矩阵HomMat2D affine_trans_image (ImageOrig, Image2, HomMat2D, \u0026#39;constant\u0026#39;, \u0026#39;false\u0026#39;) //对图像进行仿射变换，插值算法constant dev_update_window (\u0026#39;on\u0026#39;) //更新窗体 测量助手 打开方法： 助手 -\u0026gt; 打开新的Measure\nOCR流程 采集 预处理，校正 分割成独立连通域 如果每个字没有形成独立连通域（如上图），需要使用形态学，使每个汉字的各笔画在各自的一个连通域内，不同的汉字的各笔画在不同的连通域内。如“明≠日月”的关系 使用现成的，或训练 trf文件：文本与字符的关联文件，只是对应关系。可被OCR助手和OCR读取函数读取 omc文件：为训练后的文件，可用于识别。不能被OCR助手读取，只能被orc读取函数读取 识别 色彩识别 RGB转HSV\n色调（H），饱和度（S），明度（V）\n主要分析H，S分量 分类器（另外详细介绍）\n对比度相关算子 scale_image emphasize gray_range_rect等（灰度图的形态学变换） equ_histo_image直方图均衡化 几大“门派”总结 基础理论 灰度变换 增强 几何变换 分割 频域处理 形态学 复原 运动图像 图像配准 ","date":"2025-06-12T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/halcon1/","title":"Halcon基础"},{"content":"标定目的 首先，我们必须要明确一个问题：为什么需要对摄像头进行标定？\n在计算机视觉领域，我们是将三维物体转换到二维平面，这就需要确定空间物体表面某点的三维几何位置与其在二维图像中对应点之间的相互关系，这又需要建立摄像头成像的几何模型，而这些几何模型的参数就是摄像头参数，包括内参、外参、畸变参数等。\n而我们进行标定的目的：求出摄像头的内、外参数，以及畸变参数，进而可以建立摄像头成像的几何模型。\n总之，就是寻找图像和现实的数学转换关系，从而可以从图像中测量出实际数据，而在标定完成之后，一般会做两件事：\n由于每个镜头的畸变程度不同，导致成像时的图像会内凹或者外凸，通过标定可以矫正这种镜头畸变，让摄像头能够正确生成矫正后的图像 根据获得的图像重构三维场景，即三维重建，使用同一成像几何模型下的多视角二维图像来拟合出三维信息，可以认为是标定的逆过程 那么，是不是所有的摄像头都需要标定呢？答案是否。简单来说，像自动驾驶感知摄像头都是需要标定的，因为算法需要提取图像中的信息（物体类别、物体尺寸等）并将该信息参与计算，如果不进行标定工作，那么得到的视野信息就会有误，无法对物体、距离进行准确的判断，而类似于RVM摄像头（倒车影像）、监控摄像头这种类型的摄像头，它的作用仅仅是用于显示图像给人观察，图像信息并不会参与后续的计算，所以无需标定。\n在介绍标定原理前，我们先介绍摄像头成像原理、四个坐标系、摄像头参数。\n标定原理 成像原理 我们以最常见的相机为例，相机的成像原理就是小孔成像原理，后续的所有公式推导均是基于该原理进行的。通过该原理我们可以建立模型——针孔模型，如下图所示。\n左侧是相机坐标系，右侧是图像平面，相机所在位置为原点，也是成像小孔所在位置，图像平面与小孔的距离为焦距 f ，焦距的物理意义是：当图像平面与相机距离为 f 时，成像最清晰。 Z 轴为光轴，它垂直于相机平面和图像平面，与图像平面的交点叫主点(Principle point)。\n以针孔模型为基础的坐标变换示意图如下，涉及到四个坐标系：像素坐标系、图像坐标系、相机坐标系、世界坐标系。\n总之，相机成像的原理本质上就是三维空间坐标到二维空间坐标的变换。所以标定的目的就是**确定空间物体表面某点的三维几何位置与其在图像中对应点之间的相互关系，建立摄像头成像的几何模型，这些几何模型参数就是摄像头参数。**所以求出摄像头的参数，我们也就基本完成了标定过程。接下来我们介绍4个坐标系。\n四个坐标系 像素坐标系$(u,v)$\n下图便是像素坐标系，像素的坐标就是像素在图像中的位置，水平方向为 $u$ 轴，垂直方向为 $v$ 轴，左上角为顶点 $Op$ ，也被称为远点。像素坐标系反映了摄像头/相机的感光元件（CCD/CMOS）中像素的排列情况，坐标轴单位为像素（Pixel），可以认为一个小方格就代表一块像素。\n在像素坐标系中，任意一个像素坐标可以表示为 $(u_i,v_i)$ 。\n图像坐标系$(x,y)$ 像素坐标系下，每个像素的坐标是由像素表示的，但是这种表示方法不能反应图像物体的尺度大小，所以我们需要将像素坐标转换为图像坐标，方法如下：\n将像素坐标系的原点平移到图像中心，并将中心位置定位图像坐标系的原点 $O_i$ （即图像中心点），图像坐标系的 x 轴与像素坐标系的 u 轴平行且同向， y 轴与 v 轴平行且同向。我们一般描述像素点都是几行几列，所以二者的转换关系为：其中dx和dy表示每一行和每一列分别代表多少mm，即1 pixel=dx mm。\n摄像头坐标系（相机坐标系）$(x_c,y_c,z_c)$ 摄像头坐标系也叫相机坐标系，以摄像头的光轴为 z 轴，光线在摄像头光学系统的中心位置（镜头的光心处）就是原点 Oc，相机坐标系的水平轴 xc 和垂直轴 yc 分别和图像坐标系的 x 轴和 y 轴平行，如下图所示，可以发现，相机坐标系是三维坐标系，之前的像素、图像坐标系均为二维坐标系。其中，相机坐标系的原点 Oc 与图像坐标系原点 Oi 连线距离 $O_cO_i=f$ ，也就是摄像头焦距。\n世界坐标系$(X_w,Y_w,Z_w)$ 世界坐标系表达了图像和现实中的真实物体之间的一个映射关系，以此为基准可以描述相机与物体的空间位置，通过世界坐标系转换，我们可以将物体映射在图像中。对于单目视觉而言，就是真实物体尺寸和图像尺寸的映射关系。对于多目视觉而言，就需要明确各个摄像头之间的位置关系，然后将其转换在同一个坐标系下进行计算。世界坐标系如下图所示，原点为 Ow 。\n当确定唯一且不变的世界坐标系后，后续所有的坐标系都可以通过坐标变换来获得，而当平移或旋转世界坐标系后，通过转换关系可以迅速得到图像在其他坐标系下的信息。\n图12 世界坐标系\n注意： $X_w,Y_w,Z_w$ 轴并不是和其他坐标系的坐标轴平行，而是存在一定的角度和平移关系。\n从世界坐标系变换到相机坐标系属于刚体变换，即物体不会发生形变，只需要对坐标系进行平移和旋转，当对相机坐标系设定一定的参数，分别绕着 X,Y,Z 轴做平移和旋转后，就可以得到在世界坐标系的坐标。\n阅读原文 https://zhuanlan.zhihu.com/p/668358597\n","date":"2025-06-09T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/camera_calibration/","title":"摄像头标定（相机标定）及张正友标定法（张氏标定法）"},{"content":"胶片摄影与数码摄影 胶片摄影是把光学镜头的光信号投射到胶片上， 数码摄影是把光学镜头的光信号投射到传感器上，传感器把光信号依次处理为电信号和数字信号，片上计算机再把数字信号进行处理 相机的组成 只有传感器相机的成像 一棵树所有的点发出的光照射到图像传感器上，最后所成的像为 小孔成像 如果在树和传感器之间放置一个有小孔的挡板呢，只有几束光线可以穿过小孔，所成的像如下， 有小孔的挡板相当于相机中的挡板，小孔相当于光圈， 小孔相机的参数和成像结果 挡板和图像传感器之间的距离为焦距， 将成像位置移动到小孔与物体的一侧，便于理解小孔成像的几何模型\n可以把上面的图转成下面的光路图，其中 X X\nX是真实物体的一个点，相机中心是小孔，小孔与虚拟像平面的距离是焦距，主光轴是小孔与虚拟像平面的垂直线， 也可以把上面的光路图转成下面的形式，其中\nX是真实物体的点到像圈（小孔）的距离，\nY是真实物体的点到主光轴的距离，\nf是焦距，所以能得出所成像的大小与焦距成正比例关系，\n对焦距离减半时，成像尺寸减半，如下图所示，\n关于小孔成像的两个问题 Q1：成像尺寸与对焦距离的关系是什么？\n成像尺寸与对焦距离成正比 Q2：成像质量与小孔尺寸及对焦距离的关系是什么？\n小孔尺寸增大，图像变模糊 小孔尺寸过小，产生衍射模糊 小孔尺寸过小，图像变暗 只有合适的小孔尺寸，才能得到最高质量的图像 越小的孔，意味着越大的傅里叶频谱，也意味着更多的衍射\n缩小小孔还会影响光效 – 单位面积传感器的曝光量\n小孔成像的缺陷 改进： ","date":"2025-06-09T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/%E5%B0%8F%E5%AD%94%E6%88%90%E5%83%8F/","title":"小孔成像"},{"content":"如何在Halcon中进行图像配准？ 在 Halcon 中图像配准通常使用 FindShapeModel 函数，它通过形状匹配来定位模型的位置和角度。\n首先，通过创建一个形状模型来描述待匹配的图像特征，然后使用 FindShapeModel 在目标图像中查找匹配。\n可以设置匹配的精度和容忍度，以提高配准的准确性。配准后，返回模型的位置信息（位置、旋转角度等），使得物体定位更加精准。\nHalcon 中的 Region 和 Image 的区别是什么？ 在Halcon中 Region 和 Image是两种不同的数据类型。\nImage表示原始图像数据，包含每个像素的颜色或灰度值；\n而 Region则表示图像中的二值化区域，即只包含前景或背景区域。\n通过阈值处理、形态学操作可以将Image 转换为Region，进行区域分析和处理。\nRegion 更多地用于形态学、测量、分割等任务，而 Image 用于图像处理和分析。\nHalcon 中的 ReduceDomain 函数如何使用？ ReduceDomain 函数用于限制图像的处理区域，创建一个包含感兴趣区域（ROI）的新图像。\n用户可以指定一个区域（如矩形、圆形等），然后 ReduceDomain会将图像的域限制在该区域内，后续的图像处理仅在该区域内进行。\n这对于加速处理和提高计算效率非常有用，特别是在大图像中只需要关注某个特定区域时。\n如何在 Halcon 中计算物体的面积 在Halcon中，计算物体的面积可以使用 AreaCenter函数。该函数不仅返回物体的面积，还返回物体的质心坐标。\n面积的单位通常为像素，用户可以根据需要转换为实际物理单位（如毫米、厘米等）。面积计算通常用于物体计数、尺寸测量和质量控制等应用中。\nAreaCenter在处理二值图像时尤为常见，可用来计算物体、孔洞或其他感兴趣区域的面积。\n如何在 Halcon 中提取图像的边缘？ Halcon 提供了多个函数来提取图像的边缘，常用的函数包括EdgeSubPix和 EdgeGray。\nEdgeSubPix用于亚像素级边缘检测，它通过更精细的像素估计来获取边缘位置，适合高精度要求的应用。\nEdgeGray则基于图像灰度梯度进行边缘检测，适用于一般的边缘提取任务。\n边缘检测在物体识别、形状分析和轮廓提取中起着重要作用。\nHalcon 如何处理图像的灰度变换？ Halcon提供了多种灰度变换函数，如 GammaCorrection、LogTransformation、PowerTransformation等。灰度变换用于调整图像的亮度、对比度或特定的灰度特征。\n例如，GammaCorrection可以调整图像的对比度，使图像更适合后续的分析。灰度变换操作通常用于图像增强、对比度调整等，帮助突出图像中的关键信息，改善图像的质量，适应不同的处理需求。\nHalcon 中的 FindNccModel 函数是什么？ FindNccModel函数用于进行基于模板的图像匹配，利用归一化互相关（NCC）来比较目标图像和模板图像的相似性。\n该函数在实际应用中常用于定位物体或识别特定形状，适用于模板较小、旋转角度变化较小的场景。\n用户可以设置匹配精度、匹配方向和容忍度参数，以提高匹配的成功率。此函数广泛应用于工业自动化、视觉检测和质量控制等领域。\nHalcon 中如何使用深度学习进行缺陷检测？ 在Halcon中进行缺陷检测时，通常使用深度学习模型来识别产品表面上的缺陷，如裂纹、划痕等。首先，需要收集带标签的正常与缺陷样本。\n使用TrainDLClassifier进行训练，模型将学习正常样本的特征以及缺陷样本的特征。完成训练后，使用ClassifyDL算子对新图像进行缺陷检测。\n深度学习模型通过学习不同的缺陷类型，能够准确识别并分类缺陷，提高工业生产线上的检测效率。\nHalcon 中如何进行目标检测模型的训练与优化？ 在Halcon中，目标检测模型的训练涉及多种数据处理技术。\n首先，需要准备大量带有标签的训练图像，包括每个物体的边界坐标。Halcon提供TrainObjectDetection算子进行训练。\n训练过程中，通过调整学习率、批次大小、训练次数等参数来优化模型。在优化过程中，可以通过验证集上的损失值来判断模型的表现。如果模型过拟合或欠拟合，需调整网络结构、数据增强方法或优化器。\nHalcon 中的目标检测与分类的区别是什么？ 目标检测和分类是计算机视觉中的两个不同任务。目标检测不仅要求分类物体，还需要定位物体的位置（即生成边界）。\n而分类任务仅需要识别图像中的物体类别。Halcon中的目标检测使用深度学习模型（如YOLO）进行位置和类别的双重预测，而分类任务则使用单一的类别标签。\n分类关注整体的图像类别，而目标检测注重图像中所有物体的位置与类别。\nHalcon 中的异常检测是如何实现的？ 异常检测（Anomaly Detection）在Halcon中通常使用无监督学习方法来检测图像中的异常模式。\n在训练阶段，系统会学习到正常样本的特征，并通过计算图像的特征向量来与训练数据中的正常样本进行对比。使用深度学习模型或其他传统的机器学习方法（如支持向量机（SVM））来构建异常检测模型。\nHalcon中的DetectAnomalies算子可以帮助快速进行异常检测。该技术广泛应用于工业生产线上的缺陷检测。\nHalcon 中的形态学操作有什么作用，如何使用它们进行图像分析？ 形态学操作主要用于图像的结构分析，常见操作包括膨胀、腐蚀、开运算和闭运算等。\n在Halcon中，形态学操作用于去噪、连接物体、提取轮廓等任务。膨胀和腐蚀算子主要用于对图像的结构进行调整，开闭运算可以帮助去除噪声或填补空洞。\n通过组合这些操作，能够从复杂的图像中提取出所需的特征并进行后续分析。\nHalcon 如何处理非规则物体的测量？ 对于非规则物体的测量，Halcon可以使用轮廓分析和形态学操作。\n通过提取物体的边缘信息，并使用拟合算子（如拟合曲线、拟合圆等），可以从不规则形状中提取出关键信息。对于复杂的非规则物体，通常需要多步骤处理，如先通过边缘检测提取大致形状，再通过细化算法提取物体的精细特征，最后进行尺寸计算。\n在Halcon中如何处理噪声？ Halcon提供多种去噪手段，包括中值滤波、高斯滤波等。中值滤波适用于去除椒盐噪声，而高斯滤波则适用于去除高斯噪声。\n对于复杂的噪声，可以使用形态学滤波算子，如开运算和闭运算，这有助于去除小的噪点或连接分离的物体。\n此外，Halcon还提供了图像质量评估工具，用于分析图像中的噪声类型和程度，从而选择合适的去噪方法。\nHalcon 中如何进行颜色检测与分析？ 在Halcon中，颜色检测通常需要先进行颜色空间转换（例如从RGB到HSV或Lab颜色空间），然后通过颜色分割来提取感兴趣区域。\n常用的颜色分割算子如Thresho1d可以根据指定的颜色范围来提取目标区域。此外，Halcon还提供了颜色直方图分析、颜色匹配和颜色区域分析等功能，可以帮助在复杂背景下进行准确的颜色识别。\nHalcon 如何通过模板匹配进行物体定位？ 在Halcon中，模板匹配是一种通过已知模板图像定位物体的技术。使用FindShapeMode1算子，可以通过图像中的形状特征匹配来定位目标物体。\n模板匹配的基本步骤包括：首先，创建模板图像（可以是目标物体的二维图像），然后，通过图像处理算法提取出该模板的形状特征。\n匹配过程中，Halcon会根据这些特征在待检测图像中找到相似的区域，并返回匹配的位置、角度和尺度信息。\n在Halcon中如何进行物体的角度测量？ Halcon中进行角度测量通常需要首先通过边缘检测或拟合算子提取物体的边缘或特征。然后，可以使用Ang1e算子来计算两条边缘或两条拟合直线之间的角度。该角度的单位可以设置为度或弧度。\n通过多点拟合方法，可以更精确地获取物体的角度，特别是在物体存在旋转或倾斜的情况下。\n在Halcon中如何实现直线拟合？ 在Halcon中，直线拟合通过算子FitLine来实现。该算子可以根据给定的点集拟合出最佳拟合直线。\n具体步骤包括：首先通过边缘检测或阈值分割得到一系列点，然后使用FitLine算法根据这些点的坐 标信息来计算最佳拟合直线。拟合结果包括直线的斜率、截距以及拟合的误差。Halcon还提供了不同的拟合精度选项，可以根据需求调整。\nHalcon中的边缘检测算法有哪几种？ Halcon提供多种边缘检测算法，以适应不同的图像和应用场景。常见的边缘检测算法包括Sobel、Prewitt、Canny和Laplacian等。\n每种算法的原理不同，Sobel和Prewitt算子主要用于检测图像中的梯度变化，适合检测较为明显的边缘；Canny算子则是一种多阶段算法，能够检测到更精细的边缘，且不易受噪声影响。\nLaplacian算子则可以用于检测图像中的二阶导数变化，适合用于细节检测。\nHalcon如何进行二维码/条形码的读取？ 在Halcon中，读取二维码和条形码非常直接。使用相关的条形码读取算子，如FindBarcode和 FindQRCode，它们可以快速地从图像中检测到条形码或二维码。\n读取过程中，Halcon会首先定位条形码的边界，进行解码，并返回编码信息。为了提高读取的准确性，图像预处理步骤（如对比度增强或去噪）通常是必须的，尤其在图像质量较差的情况下。\n","date":"2025-04-11T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/halcon_base/","title":"Halcon基础"},{"content":"在当今的科技领域，大模型和AI技术的发展可谓是日新月异。在初学大模型的时候，大家肯定会碰到各种专业术语，让人眼花缭乱。本文将为您简单地解释一些关键术语，帮助您在学习过程中更好地理解大模型和AI的世界。\n大语言模型（LLM，Large Language Model） 大语言模型是一种基于深度学习的大规模神经网络模型，通常采用Transformer架构。它能够处理大量的语言数据并生成高质量的文本，通过大规模的数据集训练来学习语言的复杂模式。例如，GPT系列和BERT都是著名的大型语言模型，它们在自然语言处理任务中表现出色，能够进行复杂对话、文本创作等。\nTransformer Transformer是一种广泛应用于自然语言处理任务的神经网络架构，因其自注意力机制（self-attention）而能够高效处理序列数据中的长距离依赖关系，成为NLP领域的主流架构。就像AI界的乐高大师，通过“注意力机制”找到词语间的关系，例如在读侦探小说时，自动标红“凶手”和“凶器”的关键线索。\nRNN-循环神经网络（Recurrent Neural Network） RNN是一种能够处理序列数据的神经网络架构，适用于自然语言处理等任务。尽管有效，但在捕捉长期依赖方面存在局限性，容易出现梯度消失或爆炸的问题.\nLSTM-长短期记忆网络（Long Short-Term Memory） LSTM是一种特殊类型的RNN，通过特殊的门控机制解决了标准RNN在长序列训练中的梯度消失问题，从而更好地捕捉长期依赖关系。\nCNN-卷积神经网络（Convolutional Neural Network） CNN是一种专门用于处理图像数据的神经网络架构，通过卷积操作提取图像特征。此外，CNN也可应用于文本分类等其他领域。\nPrompt 输入给AI模型的提示词。在AI大模型中，用于引导模型生成特定类型输出的上下文信息或指令。例如，告诉模型“用李白的风格写三行诗，主题是秋天的奶茶”，就像和AI说话的“魔法咒语”设计术。\nPrompt Engineering-提示工程 设计和优化输入提示的过程，以提升人工智能模型输出效果的技术。通过明确的指示、相关的上下文、具体的例子以及准确的输入来精心设计提示，从而引导大语言模型生成符合预期的高质量输出。\nRAG-检索增强生成（Retrieval-Augmented Generation） RAG是一种结合了信息检索技术与语言生成模型的人工智能技术。它通过从外部知识库中检索相关信息，并将其作为提示输入给大型语言模型，以增强模型处理知识密集型任务的能力，如问答、文本摘要、内容生成等。\n向量数据库（Vector Database） 向量数据库是一种专门用于存储、检索和管理高维向量数据的数据库系统。其核心能力是快速执行向量相似性搜索，能够从海量的高维向量中快速找到与目标向量最相似的向量。\n向量相似度检索 向量相似度检索是通过计算向量之间的距离来衡量它们的相似性。常用的距离度量方法包括欧几里得距离、余弦相似性、点积等。\n希望本文的解释能够帮助您更好地理解这些术语，并为您的学习和工作提供参考。毕竟只有简单几句，没有做到图文并茂，想深入理解其所处的环节和作用，还需翻阅其他资料。大模型和AI技术的发展为我们带来了前所未有的机遇，希望您能够积极参与其中，共同推动技术的进步。\n","date":"2025-03-07T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/ai_terms/","title":"Ai Terms"},{"content":"常数时间复杂度 O(1) 示例：访问数组元素 1 2 int[] arr = { 1, 2, 3, 4, 5 }; int firstElement = arr[0]; // 直接访问第一个元素 • 时间复杂度：O(1)\n直接通过索引访问数组元素，操作次数与输入规模无关。 • 空间复杂度：O(1)\n仅使用固定内存存储变量 firstElement，无额外空间占用。\n对比：时间和空间均为常数级别，效率极高。\n线性时间复杂度 O(n) 示例1：遍历数组求和 1 2 3 4 5 6 7 int SumArray(int[] arr) { int sum = 0; foreach (int num in arr) { // 遍历每个元素 sum += num; } return sum; } • 时间复杂度：O(n)\n需要遍历数组的每个元素，操作次数与输入规模 n 成线性关系。 • 空间复杂度：O(1)\n仅使用固定变量 sum，不随输入规模增加。\n示例2：复制数组 1 2 3 4 5 6 7 int[] CopyArray(int[] arr) { int[] newArr = new int[arr.Length]; for (int i = 0; i \u0026lt; arr.Length; i++) { newArr[i] = arr[i]; } return newArr; } • 时间复杂度：O(n)\n遍历数组复制每个元素。 • 空间复杂度：O(n)\n需要额外创建一个长度为 n 的新数组。\n对比：\n• 同样是 O(n) 时间，SumArray 的空间复杂度更优（O(1) vs O(n)）。\n• 空间与时间的权衡：复制数组牺牲空间来保留原始数据。\n平方时间复杂度 O(n²) 示例：冒泡排序 1 2 3 4 5 6 7 8 9 10 11 void BubbleSort(int[] arr) { for (int i = 0; i \u0026lt; arr.Length; i++) { for (int j = 0; j \u0026lt; arr.Length - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } • 时间复杂度：O(n²)\n双重循环导致操作次数与 n² 成正比。 • 空间复杂度：O(1)\n原地排序，仅用临时变量 temp，无额外空间占用。\n对比：时间效率低但空间效率高，适合内存受限的场景。\n递归算法的复杂度分析 示例1：斐波那契数列（递归实现） 1 2 3 4 int Fibonacci(int n) { if (n \u0026lt;= 1) return n; return Fibonacci(n - 1) + Fibonacci(n - 2); } • 时间复杂度：O(2ⁿ)\n递归调用指数级增长（每次调用产生两个子问题）。 • 空间复杂度：O(n)\n递归调用栈深度为 n，占用线性空间。\n示例2：斐波那契数列（迭代实现） 1 2 3 4 5 6 7 8 9 10 int FibonacciIterative(int n) { if (n \u0026lt;= 1) return n; int a = 0, b = 1, sum; for (int i = 2; i \u0026lt;= n; i++) { sum = a + b; a = b; b = sum; } return b; } • 时间复杂度：O(n)\n单层循环遍历 n 次。 • 空间复杂度：O(1)\n仅使用固定变量 a, b, sum。\n对比：\n• 递归实现牺牲时间（O(2ⁿ)）和空间（O(n)）换取代码简洁性。\n• 迭代实现通过优化，时间降至 O(n)，空间降至 O(1)，但代码稍复杂。\n时间与空间的权衡 哈希表：以空间换时间 1 2 3 4 5 6 7 8 bool HasDuplicate(int[] arr) { HashSet\u0026lt;int\u0026gt; seen = new HashSet\u0026lt;int\u0026gt;(); foreach (int num in arr) { if (seen.Contains(num)) return true; seen.Add(num); } return false; } • 时间复杂度：O(n)\nHashSet 的插入和查询操作平均为 O(1)。 • 空间复杂度：O(n)\n需要额外存储所有元素的哈希表。\n对比：\n通过牺牲 O(n) 的空间，将时间从暴力法的 O(n²) 优化到 O(n)。\n总结对比 场景 时间复杂度 空间复杂度 核心权衡 直接访问数组元素 O(1) O(1) 无 遍历数组求和 O(n) O(1) 时间线性增长，空间高效 复制数组 O(n) O(n) 空间换数据完整性 冒泡排序 O(n²) O(1) 时间低效，空间高效 斐波那契递归 O(2ⁿ) O(n) 时间和空间均低效，代码简洁 斐波那契迭代 O(n) O(1) 时间高效，空间高效 哈希表查重 O(n) O(n) 空间换时间 核心思想：\n• 时间复杂度关注操作次数的增长率，空间复杂度关注内存占用的增长率。\n• 实际开发中需根据场景选择：\n• 内存敏感（如嵌入式系统）优先优化空间复杂度。\n• 时间敏感（如实时计算）优先优化时间复杂度。\n• 递归需警惕栈溢出风险，迭代更可控。\n","date":"2025-03-06T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/time_complexity_and_space_complexity/","title":"时间复杂度与空间复杂度"},{"content":"手眼标定原理 手眼标定是指求解出工业机器人的末端坐标系与相机坐标系之间的坐标变换关系，或者工业机器人的基底坐标系与相机坐标系之间的坐标变换关系。手眼标定有两种情形：第一种是相机（眼）固定在机器臂（手）的末端，相机相对于机器臂末端是固定的，相机跟随机器臂移动，这种方式的手眼标定成为 Eye-in-hand；第二种是相机（眼）和机器臂（手）分离，相机相对于工业机器人的基座是固定的，机器臂的运动对相机没有影响, 这种方式的手眼标定成为 Eye-to-hand。\n眼在手上的手眼标定 对于 Eye-in-hand 手眼标定方式，需要求解工业机器人的末端坐标系与相机坐标系之间的坐标转换关系。 Eye-in-hand 手眼标定的原理示意图如图 1所示。这其中有几个坐标系， 基础坐标系（用 base 表示） 是机器臂的基底坐标系，末端坐标系（用 end 表示） 是机器臂的末端坐标系， 相机坐标系（用 cam 表示） 是固定在机器臂上面的相机自身坐标系，标定物坐标系（用 cal 表示）是标定板所在的坐标系。任意移动两次机器臂，由于标定板和机器臂的基底是不动的，因此对于某个世界点，其在 base 坐标系和 cal 坐标系下的坐标值不变，在 end 坐标系和 cam 坐标系下的坐标值随着机器臂的运动而改变。根据这一关系，可以求解出end坐标系和 cam 坐标系之间的转换矩阵。具体求解过程如下。\n对于手眼标定矩阵的求解，即求解出 end 坐标系和 cam 坐标系之间的转换矩阵，目前有许多方法，基本原理都是根据上述约束关系来求解的。 cal 坐标系下的某个点 P0 ，根据已知的相机外参（转换矩阵T 1）能够转换到 cam 坐标系下点 P1,再根据待求的手眼标定矩阵（转换矩阵 X ）能够转换到 end 坐标系下点 P2，然后根据已知的机器人自身参数（转换矩阵T3）能够转换到 base 坐标系下点 P3。因此能够得到关系式如下： $$ T_3XT_1P_0=P_3 $$ 移动机器臂，对于同一点，P0 和P3的坐标值不变，只是P1 和P2 的坐标值改变了，上述关系式变为如下形式： $$ T_3^\\prime XT_1^\\prime P_0=P_3 $$ 上式中$ T_3^\\prime $和$ T_1^\\prime$同样是第二次测量的已知参数。联立(1)和(2)式可以得到如下关系式 $$ T_3XT_1=T3^\\prime XT_1^\\prime $$\n对式(3)变换一下，得： $$ T_3^ {\\prime-1}T_3X=XT_1^\\prime T_1^{-1} $$ 上式可以看成$ A X = X B $方程形式，且矩阵$ A=T_3^{\\prime-1}T_3 $和$ B=T_1^\\prime T_1^{-1} $都是已知的。对手眼标定方程$ A X = X B $求解，即可得到手眼转换矩阵X的值\n","date":"2025-03-04T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/eye_to_handle/","title":"手眼标定"},{"content":"C# 泛型的底层实现是 CLR（公共语言运行时）和 JIT（即时编译器）协作的结果，其核心目标是实现 类型安全、性能优化 和 代码复用。以下是其底层实现的关键细节：\n泛型的运行时支持 C# 泛型是 \u0026ldquo;真泛型\u0026rdquo;（与 Java 的类型擦除不同），泛型类型参数在运行时完全保留。这意味着：\n类型信息保留\n泛型类型参数（如 T）会被编译到 IL（中间语言）和元数据中，CLR 在运行时可以感知具体类型。\n动态实例化\n泛型类型（如 List\u0026lt;int\u0026gt;）在首次使用时由 JIT 动态生成具体实现，而非编译时展开。\n值类型 vs 引用类型的实现差异 值类型（如 int, struct） 独立代码生成\nCLR 会为每个值类型参数生成 完全独立的机器代码。例如：\nList\u0026lt;int\u0026gt; 和 List\u0026lt;double\u0026gt; 在运行时是不同的类型，拥有独立的方法表和内存布局。\n优势：避免装箱拆箱，直接操作原生数据类型。 内存布局优化\n值类型泛型的实例在内存中连续存储，无需指针间接访问。 引用类型（如 string, class） 代码共享\n所有引用类型参数共享 同一份 JIT 编译后的代码。例如：\nList\u0026lt;string\u0026gt; 和 List\u0026lt;object\u0026gt; 共享大部分实现，因为它们的内存布局（指针大小）一致。\n优势：减少代码膨胀，节省内存。 类型擦除的假象\n虽然代码共享，但运行时类型信息（如 typeof(List\u0026lt;\u0026gt;).GetGenericArguments()）仍然完整保留。 泛型类型的实例化过程 JIT 编译时的动态生成 当首次使用某个泛型类型（如 List\u0026lt;int\u0026gt;）时，JIT 编译器会根据类型参数生成对应的 本地机器代码。 值类型：生成专用代码（如直接操作 int 的指令）。 引用类型：生成通用代码（通过指针操作，适配所有引用类型）。 代码共享机制 引用类型共享条件\n若两个引用类型参数的 内存布局相同（如 string 和 object），则共享同一份代码。 值类型不共享\n每个值类型（如 int、long）生成独立代码，因其内存大小不同。 泛型方法的内联优化 JIT 编译器可能对泛型方法进行 内联展开（尤其是值类型参数），例如：\n1 2 3 4 5 public static T Add\u0026lt;T\u0026gt;(T a, T b) where T : struct =\u0026gt; a + b; // 调用 Add\u0026lt;int\u0026gt;(1, 2) 时，JIT 可能直接生成类似以下机器码： // mov eax, 1 // add eax, 2 优势：消除方法调用开销，进一步提升性能。\n静态字段的隔离 每个封闭泛型类型（如 MyClass\u0026lt;int\u0026gt; 和 MyClass\u0026lt;string\u0026gt;）拥有 独立的静态字段：\n1 2 3 4 5 6 7 public class MyClass\u0026lt;T\u0026gt; { public static int Count; } MyClass\u0026lt;int\u0026gt;.Count = 10; MyClass\u0026lt;string\u0026gt;.Count = 20; // 与 MyClass\u0026lt;int\u0026gt;.Count 完全独立 底层原因：不同泛型类型在运行时被视为完全不同的类型。\n类型约束的底层实现 类型约束（如 where T : IComparable）通过以下方式实现：\n编译时验证\n编译器确保所有对 T 的操作符合约束（如调用 T.CompareTo 方法）。 运行时验证\n当通过反射动态创建泛型实例时，CLR 会检查类型参数是否满足约束。 协变（Covariance）与逆变（Contravariance） 协变（out T） 允许将 IEnumerable\u0026lt;Cat\u0026gt; 赋值给 IEnumerable\u0026lt;Animal\u0026gt;。 实现方式：CLR 通过虚方法表和类型转换表动态处理类型兼容性。 逆变（in T） 允许将 Action\u0026lt;Animal\u0026gt; 赋值给 Action\u0026lt;Cat\u0026gt;。 实现方式：JIT 生成通用代码，确保输入参数类型安全。 泛型与性能优化 避免装箱拆箱\n值类型泛型（如 List\u0026lt;int\u0026gt;）直接操作栈内存，无需将 int 装箱为 object。\n缓存机制\nCLR 会缓存已生成的泛型类型代码，避免重复编译。\n内存效率\n值类型泛型集合（如 List\u0026lt;int\u0026gt;）在内存中连续存储，比 ArrayList（存储 object）更紧凑。\n对比 C++ 模板 特性 C# 泛型 C++ 模板 实例化时机 运行时由 JIT 动态生成 编译时展开为具体代码 类型安全 编译时 + 运行时双重检查 编译时模板展开后检查 代码生成 值类型独立生成，引用类型共享代码 所有类型独立生成代码 跨程序集支持 是（元数据保留泛型信息） 否（模板定义需在头文件中） 反射与泛型 通过反射可以动态操作泛型类型：\n1 2 3 4 5 6 7 8 9 // 动态创建 List\u0026lt;int\u0026gt; Type openType = typeof(List\u0026lt;\u0026gt;); Type closedType = openType.MakeGenericType(typeof(int)); object list = Activator.CreateInstance(closedType); // 调用泛型方法 MethodInfo method = typeof(MyClass).GetMethod(\u0026#34;MyMethod\u0026#34;); MethodInfo closedMethod = method.MakeGenericMethod(typeof(string)); closedMethod.Invoke(null, new object[] { \u0026#34;test\u0026#34; }); 底层 IL 表示 泛型在 IL（中间语言）中使用 类型参数占位符（如 !!0）表示：\n1 2 3 4 5 6 7 // 泛型方法的 IL 代码示例 .method public static void Swap\u0026lt;T\u0026gt;(!!T\u0026amp; a, !!T\u0026amp; b) { ldarg.0 ldarg.1 // 交换操作的 IL 指令 } 总结 C# 泛型的底层实现通过 CLR 和 JIT 的深度协作，实现了：\n真泛型：运行时保留类型信息，支持反射和动态类型操作。 高性能：值类型专用代码、引用类型共享代码、内联优化。 类型安全：编译时和运行时双重验证。 灵活性：协变/逆变、泛型约束、跨程序集支持。 这种设计使 C# 泛型在效率、安全性和灵活性上达到了平衡，成为现代 C# 开发的核心工具。\n","date":"2025-02-21T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/generictype-1/","title":"C#泛型底层"},{"content":"C# 泛型是一种强大的编程特性，允许开发者编写可重用、类型安全且高效的代码。通过泛型，可以在定义类、接口、方法或委托时使用类型参数，实际使用时再指定具体类型。以下是关于 C# 泛型的详细介绍：\n泛型的核心优势 类型安全 泛型在编译时检查类型，避免运行时类型转换错误（如 object 的装箱拆箱操作）。\n代码复用 同一套逻辑可适用于多种数据类型，无需为不同类型重复编写代码。\n性能优化 避免值类型的装箱拆箱操作，提升性能（例如使用 List\u0026lt;int\u0026gt; 而非 ArrayList）。\n泛型的基本用法 泛型类（Generic Class） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class GenericRepository\u0026lt;T\u0026gt; { private List\u0026lt;T\u0026gt; _items = new List\u0026lt;T\u0026gt;(); public void Add(T item) =\u0026gt; _items.Add(item); public T Get(int index) =\u0026gt; _items[index]; } // 使用示例 var intRepo = new GenericRepository\u0026lt;int\u0026gt;(); intRepo.Add(42); var stringRepo = new GenericRepository\u0026lt;string\u0026gt;(); stringRepo.Add(\u0026#34;Hello\u0026#34;); 泛型接口（Generic Interface） 1 2 3 4 5 6 7 8 9 public interface IComparer\u0026lt;T\u0026gt; { int Compare(T x, T y); } public class IntComparer : IComparer\u0026lt;int\u0026gt; { public int Compare(int x, int y) =\u0026gt; x.CompareTo(y); } 泛型方法（Generic Method） 1 2 3 4 5 6 7 8 9 10 public static void Swap\u0026lt;T\u0026gt;(ref T a, ref T b) { T temp = a; a = b; b = temp; } // 使用示例 int x = 1, y = 2; Swap(ref x, ref y); // 编译器自动推断类型为 int 泛型委托（Generic Delegate） 1 2 3 4 5 public delegate T Processor\u0026lt;T\u0026gt;(T input); // 使用示例 Processor\u0026lt;int\u0026gt; square = n =\u0026gt; n * n; int result = square(5); // 25 类型约束（Type Constraints） 通过 where 关键字限制泛型参数的类型范围，增强类型安全性。\n约束类型 示例 说明 值类型 where T : struct T 必须是值类型（如 int） 引用类型 where T : class T 必须是引用类型（如 string） 无参构造函数 where T : new() T 必须有默认构造函数 基类约束 where T : SomeBaseClass T 必须继承自指定基类 接口约束 where T : ISomeInterface T 必须实现指定接口 组合约束 where T : class, new() 多条件约束 示例：\n1 2 3 4 public class Factory\u0026lt;T\u0026gt; where T : IAnimal, new() { public T Create() =\u0026gt; new T(); } 协变与逆变（Covariance \u0026amp; Contravariance） 允许在泛型类型中更灵活地处理继承关系，通过 out（协变）和 in（逆变）关键字实现。\n协变（Covariance） 用于返回值类型（out T）。 允许将派生类型作为泛型参数传递给接受基类型的接口。 1 2 IEnumerable\u0026lt;Cat\u0026gt; cats = new List\u0026lt;Cat\u0026gt;(); IEnumerable\u0026lt;Animal\u0026gt; animals = cats; // 合法，因为 IEnumerable\u0026lt;out T\u0026gt; 逆变（Contravariance） 用于参数类型（in T）。 允许将基类型作为泛型参数传递给接受派生类型的接口。 1 2 3 Action\u0026lt;Animal\u0026gt; animalAction = a =\u0026gt; a.Eat(); Action\u0026lt;Cat\u0026gt; catAction = animalAction; // 合法，因为 Action\u0026lt;in T\u0026gt; catAction(new Cat()); // 执行 animalAction 泛型中的默认值 使用 default(T) 获取类型的默认值：\n引用类型：null 值类型：0、false 等。 1 public T GetDefault\u0026lt;T\u0026gt;() =\u0026gt; default(T); 泛型与集合 .NET 提供了丰富的泛型集合类，如：\nList\u0026lt;T\u0026gt;：动态数组 Dictionary\u0026lt;TKey, TValue\u0026gt;：键值对 Queue\u0026lt;T\u0026gt;：先进先出队列 Stack\u0026lt;T\u0026gt;：后进先出栈 对比非泛型集合（如 ArrayList）： 泛型集合无需类型转换，直接操作具体类型。 避免因错误类型导致的运行时异常。 高级主题 反射与泛型 通过反射动态创建泛型类型或方法：\n1 2 3 Type openType = typeof(List\u0026lt;\u0026gt;); Type closedType = openType.MakeGenericType(typeof(int)); List\u0026lt;int\u0026gt; intList = (List\u0026lt;int\u0026gt;)Activator.CreateInstance(closedType); 泛型类型推断 编译器根据参数自动推断类型：\n1 2 var list = new List\u0026lt;int\u0026gt; { 1, 2, 3 }; var first = list.First(); // 推断返回类型为 int 静态成员行为 每个封闭泛型类型（如 MyClass\u0026lt;int\u0026gt; 和 MyClass\u0026lt;string\u0026gt;）拥有独立的静态成员。\n使用场景 需要处理多种数据类型的通用算法（如排序、搜索）。 构建可复用的库或框架（如 ORM 中的泛型 Repository）。 实现设计模式（工厂模式、策略模式等）。 总结 C# 泛型通过类型参数化显著提升了代码的灵活性和安全性，是编写高效、可维护代码的重要工具。合理使用泛型约束、协变/逆变等特性，可以进一步优化设计，减少重复代码。\n","date":"2025-02-21T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/generictype-base/","title":"C#泛型基础"},{"content":"在Markdown中，标题一般建议从一级标题（即单个#）开始，作为文档的主标题或文章名称，然后依次使用二级标题（##）和三级标题（###）来组织子章节。这种层级结构既清晰又美观，符合大多数文档的排版需求。\n具体建议： 一级标题用于文档或文章的主标题（如# 文章标题）； 二级标题用于主要章节（如## 引言、## 方法）； 三级标题用于子章节（如### 实验设计、### 数据分析）； 四级及以下标题应谨慎使用，避免层级过深导致结构复杂。 注意事项： 避免标题层级跳跃（如直接从一级跳到三级）； 同一级标题下避免仅有一个子标题（如二级标题下仅一个三级标题）； 保持标题简洁，减少四级标题的使用。 ","date":"2025-02-21T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/markdown-skill/","title":"Markdown注意事项"},{"content":"在对比 .NET Framework 和 .NET Core 在托管和非托管代码上的处理时，需要考虑两者的运行机制以及在 IIS 中的配置差异。以下从运行时管理、托管与非托管代码支持、性能和场景等方面分析两者的区别：\n托管与非托管代码概述 托管代码： 由 CLR（公共语言运行时） 管理，运行时提供内存管理、垃圾回收、类型安全等功能。 适用于使用 C#、VB.NET 等语言开发的代码。 运行时环境： .NET Framework 使用其自身的运行时 (.NET CLR)。 .NET Core 使用跨平台的 CoreCLR 或 .NET Runtime。 非托管代码： 不由 CLR 管理，直接与操作系统交互（例如原生 C/C++ 代码）。 不享受 CLR 提供的功能，开发者需要自己处理内存分配、资源释放等。 在 .NET Framework 和 .NET Core 中，可以通过 P/Invoke（平台调用）等方式调用非托管代码。 IIS 托管的差异 .NET Framework 运行机制： 在 IIS 中，.NET Framework 应用程序完全依赖 IIS 的托管功能。 IIS 加载指定版本的 .NET CLR（例如 v4.0），托管代码在 .NET CLR 中执行。 配置选项： 托管代码：需要在应用程序池中选择对应的 \u0026ldquo;.NET CLR 版本\u0026rdquo;（如 v2.0 或 v4.0）。 非托管代码：设置为“无托管代码”，表示不加载 .NET CLR，IIS 仅用作运行非托管应用（如经典 ASP 或纯原生代码）。 特点： IIS 负责托管应用的生命周期和运行环境。 强依赖于 Windows 和 .NET Framework，无法跨平台。 .NET Core 运行机制： .NET Core 应用程序通过 Kestrel Web Server 运行。 IIS 仅作为反向代理，转发 HTTP 请求到 Kestrel，不直接托管代码。 .NET Core 的运行时独立于 IIS，可以跨平台运行。 配置选项： 托管代码：无需选择 .NET CLR，推荐将“.NET CLR 版本”设置为“无托管代码”。 非托管代码：同样选择“无托管代码”，因为 .NET Core 自带运行时，IIS 只负责请求转发。 特点： 独立运行时（Self-contained Deployment）使其不依赖服务器上的 .NET 运行时。 轻量级设计，更高性能，跨平台能力强。 性能对比 特性 .NET Framework .NET Core 托管代码性能 较高，但受限于 IIS 和 Windows 平台。 更高性能，Kestrel 比 IIS 更轻量，独立于平台运行。 非托管代码性能 支持 P/Invoke，但调用非托管代码时需要更高的资源管理成本。 同样支持 P/Invoke，性能优化更好，跨平台能力更强。 资源开销 IIS 加载 .NET CLR 时有一定的内存和启动开销。 不依赖 IIS 托管，运行时更轻量，仅用 IIS 作为反向代理时开销低。 启动速度 较慢，依赖 IIS 初始化和加载 .NET CLR。 较快，独立运行时不依赖 IIS 的初始化。 适用场景对比 场景 .NET Framework .NET Core 传统 Windows 应用 适用于需要紧密集成 Windows 平台的应用（如企业内部系统）。 不适合传统依赖 Windows 的应用。 跨平台 Web 应用 不支持跨平台，运行时只能在 Windows 上。 完美支持跨平台（Windows、Linux、macOS）。 高性能 Web 应用 性能较低（受限于 IIS 的开销和托管模型）。 性能更高，Kestrel 和反向代理的组合效率更优。 混合托管与非托管 支持，但托管代码和非托管代码的交互需要注意性能损耗。 更高效，特别是在调用本机库时，P/Invoke 更加优化。 总结对比 特性 .NET Framework .NET Core 托管模型 强依赖 IIS 提供的托管环境 独立托管，通过 Kestrel 与 IIS 集成 运行时环境 依赖 .NET CLR 使用独立的 .NET Core 运行时 IIS 配置推荐 设置为对应 .NET CLR 版本 设置为“无托管代码” 跨平台支持 不支持 完全支持跨平台 性能 较低（受限于 IIS 和 .NET Framework） 更高（轻量级 Kestrel 和独立运行时） 如果你的应用需要高性能、跨平台支持或轻量级架构，选择 .NET Core 是更优的方案。而如果你的应用是针对 Windows 平台的传统应用，且需要使用 .NET Framework 的完整功能，.NET Framework 会是合适的选择。\n","date":"2025-01-16T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/iis_hosted_unhosted/","title":"IIS中.net core和.net framework托管和非托管的对比"},{"content":"反序列化Json常用方式 JsonConvert.DeserializeObject\u0026lt;dynamic\u0026gt;(string) JObject.Parse(string) ​ 这里采用enchmarkDotNet进行测试，我们直接上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #load \u0026#34;BenchmarkDotNet\u0026#34; void Main() { RunBenchmark(); return; // Uncomment this line to initiate benchmarking. } string complexJsonString = @\u0026#34; { \u0026#34;\u0026#34;id\u0026#34;\u0026#34;: 12345, \u0026#34;\u0026#34;name\u0026#34;\u0026#34;: \u0026#34;\u0026#34;Sample Name\u0026#34;\u0026#34;, \u0026#34;\u0026#34;isActive\u0026#34;\u0026#34;: true, \u0026#34;\u0026#34;details\u0026#34;\u0026#34;: { \u0026#34;\u0026#34;description\u0026#34;\u0026#34;: \u0026#34;\u0026#34;This is a sample description.\u0026#34;\u0026#34;, \u0026#34;\u0026#34;createdAt\u0026#34;\u0026#34;: \u0026#34;\u0026#34;2025-01-13T00:00:00Z\u0026#34;\u0026#34;, \u0026#34;\u0026#34;tags\u0026#34;\u0026#34;: [\u0026#34;\u0026#34;example\u0026#34;\u0026#34;, \u0026#34;\u0026#34;performance\u0026#34;\u0026#34;, \u0026#34;\u0026#34;test\u0026#34;\u0026#34;] }, \u0026#34;\u0026#34;metrics\u0026#34;\u0026#34;: [1, 2, 3, 4, 5] }\u0026#34;; string easyString = @\u0026#34;{ \u0026#34;\u0026#34;id\u0026#34;\u0026#34;: 12345, \u0026#34;\u0026#34;name\u0026#34;\u0026#34;: \u0026#34;\u0026#34;Sample Name\u0026#34;\u0026#34; }\u0026#34;; [Benchmark] public void JsonConvert_DeserializeObject_complexJsonString() =\u0026gt; JsonConvert.DeserializeObject\u0026lt;dynamic\u0026gt;(complexJsonString); [Benchmark] public void JObject_Parse_complexJsonString() =\u0026gt; JObject.Parse(complexJsonString); [Benchmark] public void JsonConvert_DeserializeObject_easyString() =\u0026gt; JsonConvert.DeserializeObject\u0026lt;dynamic\u0026gt;(easyString); [Benchmark] public void JObject_Parse_easyString() =\u0026gt; JObject.Parse(easyString); [GlobalSetup] public void BenchmarkSetup() { // optional setup code... } ​ 我们来看结果 结论 ​ 可以看出不论是复杂Json还是简单Json，JObject.Parse都是最优选择\n","date":"2025-01-15T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/deserializejson/","title":"Newtonsoft反序列化Json常用方式的性能对比"},{"content":"C# 12 中的新增功能 主构造函数 现在可以在任何 class 和 struct 中创建主构造函数。 主构造函数不再局限于 record 类型。 主构造函数参数都在类的整个主体的范围内。 为了确保显式分配所有主构造函数参数，所有显式声明的构造函数都必须使用 this() 语法调用主构造函数。 将主构造函数添加到 class 可防止编译器声明隐式无参数构造函数。 在 struct 中，隐式无参数构造函数初始化所有字段，包括 0 位模式的主构造函数参数。\n编译器仅在 record 类型（record class 或 record struct 类型）中为主构造函数参数生成公共属性。 对于主构造函数参数，非记录类和结构可能并不总是需要此行为。\n有关主构造函数的详细信息，请参阅探索主构造函数的教程和实例构造函数的相关文章。\n集合表达式 集合表达式引入了新的 语法来创建常见的集合值。 可以使用展开运算符 .. 将其他集合内联到这些值中。\n可以创建多个类似集合的类型，而无需使用外部 BCL(Base Class Library) 支持。 这些类型包括：\n数组类型，例如 int[]。 System.Span\u0026lt;T\u0026gt; 和 System.ReadOnlySpan\u0026lt;T\u0026gt;。 支持集合初始值设定项的类型，例如 System.Collections.Generic.List\u0026lt;T\u0026gt;。 以下示例演示了集合表达式的使用：\nC#\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Create an array: int[] a = [1, 2, 3, 4, 5, 6, 7, 8]; // Create a list: List\u0026lt;string\u0026gt; b = [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;]; // Create a span Span\u0026lt;char\u0026gt; c = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;]; // Create a jagged 2D array: int[][] twoD = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]; // Create a jagged 2D array from variables: int[] row0 = [1, 2, 3]; int[] row1 = [4, 5, 6]; int[] row2 = [7, 8, 9]; int[][] twoDFromVariables = [row0, row1, row2]; 展开运算符（集合表达式中的 ..）可将其参数替换为该集合中的元素。 参数必须是集合类型。 以下示例演示了展开运算符的工作原理：\nC#\n1 2 3 4 5 6 7 8 9 10 int[] row0 = [1, 2, 3]; int[] row1 = [4, 5, 6]; int[] row2 = [7, 8, 9]; int[] single = [.. row0, .. row1, .. row2]; foreach (var element in single) { Console.Write($\u0026#34;{element}, \u0026#34;); } // output: // 1, 2, 3, 4, 5, 6, 7, 8, 9, 展开运算符的操作数是可以枚举的表达式。 展开运算符可计算枚举表达式的每个元素。\n可以在需要元素集合的任何位置使用集合表达式。 它们可以指定集合的初始值，也可以作为参数传递给采用集合类型的方法。 可以在有关集合表达式的语言参考文章或功能规范中详细了解集合表达式。\nref readonly 参数 C# 添加了 in 参数作为传递只读引用的方法。 in 参数既允许变量和值，并且无需对参数进行任何注释即可使用。\n添加 ref readonly 参数可以更清楚地了解可能使用 ref 参数或 in 参数的 API：\n即使参数未修改，在 in 引入之前创建的 API 也可能会使用 ref。 可以使用 ref readonly 更新这些 API。 对于调用方来说，这不会是一项中断性变更，就像参数 ref 更改为 in 那样。 示例为 System.Runtime.InteropServices.Marshal.QueryInterface。 采用 in 参数但逻辑上需要变量的 API。 值表达式不起作用。 示例为 System.ReadOnlySpan\u0026lt;T\u0026gt;.ReadOnlySpan\u0026lt;T\u0026gt;(T)。 使用 ref 的 API，因为它们需要变量，但不改变该变量。 示例为 System.Runtime.CompilerServices.Unsafe.IsNullRef。 若要了解有关 ref readonly 参数的详细信息，请参阅有关语言参考中的参数修饰符的文章，或参考只读参数功能规范。\n默认 Lambda 参数 现在可以为 Lambda 表达式的参数定义默认值。 语法和规则与将参数的默认值添加到任何方法或本地函数相同。\n可以在有关 Lambda 表达式的文章中详细了解 Lambda 表达式上的默认参数。\n任何类型的别名 可以使用 using 别名指令创建任何类型的别名，而不仅仅是命名类型。 这意味着可以为元组类型、数组类型、指针类型或其他不安全类型创建语义别名。 有关详细信息，请参阅功能规范。\n内联数组 运行时团队和其他库作者使用内联数组来提高应用的性能。 内联数组使开发人员能够创建固定大小的 struct 类型数组。 具有内联缓冲区的结构应提供类似于不安全的固定大小缓冲区的性能特征。 你可能不会声明自己的内联数组，但当它们从运行时 API 作为 System.Span\u0026lt;T\u0026gt; 或 System.ReadOnlySpan\u0026lt;T\u0026gt; 对象公开时，你将透明地使用这些数组。\n内联数组的声明类似于以下 struct：\nC#\n1 2 3 4 5 [System.Runtime.CompilerServices.InlineArray(10)] public struct Buffer { private int _element0; } 它们的用法与任何其他数组类似：\nC#\n1 2 3 4 5 6 7 8 9 10 var buffer = new Buffer(); for (int i = 0; i \u0026lt; 10; i++) { buffer[i] = i; } foreach (var i in buffer) { Console.WriteLine(i); } 区别在于编译器可以利用有关内联数组的已知信息。 你可能会像使用任何其他数组一样使用内联数组。 有关如何声明内联数组的详细信息，请参阅有关 struct 类型的语言参考。\nExperimental 属性 可以使用 System.Diagnostics.CodeAnalysis.ExperimentalAttribute 来标记类型、方法或程序集，以指示实验性特征。 如果访问使用 ExperimentalAttribute 注释的方法或类型，编译器将发出警告。 用 Experimental 特性标记的程序集中包含的所有类型都是实验性的。 可以在有关编译器读取的常规属性的文章或功能规范中阅读详细信息。\n拦截器 警告\n拦截器是一项试验性功能，在 C# 12 的预览模式下提供。 在将来的版本中，该功能可能会发生中断性变更或被删除。 因此，不建议将其用于生产或已发布的应用程序。\n若要使用拦截器，用户项目必须指定属性 \u0026lt;InterceptorsPreviewNamespaces\u0026gt;。 这是允许包含拦截器的命名空间的列表。\n例如：\u0026lt;InterceptorsPreviewNamespaces\u0026gt;$(InterceptorsPreviewNamespaces);Microsoft.AspNetCore.Http.Generated;MyLibrary.Generated\u0026lt;/InterceptorsPreviewNamespaces\u0026gt;\n拦截器是一种方法，该方法可以在编译时以声明方式将对可拦截方法的调用替换为对其自身的调用。 通过让拦截器声明所拦截调用的源位置，可以进行这种替换。 拦截器可以向编译中（例如在源生成器中）添加新代码，从而提供更改现有代码语义的有限能力。\n在源生成器中使用拦截器修改现有编译的代码，而非向其中添加代码。 源生成器将对可拦截方法的调用替换为对拦截器方法的调用\n。\n如果你有兴趣尝试拦截器，可以阅读功能规范来了解详细信息。 如果使用该功能，请确保随时了解此实验功能的功能规范中的任何更改。 最终确定功能后，我们将在本站点上添加更多指导。\n","date":"2024-11-28T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/what_new_in_csharp12/","title":"C# 12 中的新增功能"},{"content":"在 WPF 中，ObservableCollection 和 BindingList 都是常用的数据集合类型，但它们的用途和功能有一些不同。以下是两者的详细对比：\n数据变更通知机制 ObservableCollection\u0026lt;T\u0026gt;: 实现方式: 实现了 INotifyCollectionChanged 和 INotifyPropertyChanged 接口。 功能: 当集合中元素的添加、移除或整个集合的刷新等操作发生时，ObservableCollection 会触发 集合变更通知（CollectionChanged事件），比如 UI 会自动更新。但是一旦其中的元素发生了改变，将不会通知 优势: 适合绑定到 WPF 的 ItemsControl（如 ListBox、DataGrid）时实时更新界面。 BindingList\u0026lt;T\u0026gt;: 实现方式: 实现了 IBindingList 接口。 功能: 提供了更细粒度的控制，包括数据绑定和排序功能，但默认情况下不支持批量通知。 通知: 只会在集合的元素被添加或删除时触发事件，而 元素属性变更（ListChanged） 通知需要集合中的元素实现 INotifyPropertyChanged。 元素属性变化通知 ObservableCollection\u0026lt;T\u0026gt;: 支持情况: 集合本身不监听集合中元素的属性变化。如果需要更新绑定，则集合中每个元素需实现 INotifyPropertyChanged。 应用场景: 适合动态变化的集合（添加/删除），但对于元素属性变化通知较弱。 BindingList\u0026lt;T\u0026gt;: 支持情况: 原生支持 INotifyPropertyChanged。如果元素实现了该接口，则 BindingList 会响应元素属性的变化。 应用场景: 更适合需要频繁更新单个元素属性的场景。 排序和筛选 ObservableCollection\u0026lt;T\u0026gt;: 排序支持: 不支持直接排序。需要手动实现，通常借助 CollectionView 或 Linq 实现排序或筛选。 灵活性: 主要适合简单的数据绑定和动态更新。 BindingList\u0026lt;T\u0026gt;: 排序支持: 内置支持排序功能（通过实现 IBindingList 提供 ApplySort 方法）。 使用场景: 适合需要排序或筛选功能的集合操作。 性能 ObservableCollection\u0026lt;T\u0026gt;: 因为其设计用于 WPF 数据绑定，通知机制针对 WPF 优化，所以性能更高。 BindingList\u0026lt;T\u0026gt;: 功能更通用，通知机制在 WinForms 环境中表现更优，在 WPF 中性能稍逊。 线程安全 两者均不是线程安全的，如果需要在多线程环境中操作集合，应使用同步机制（如 Dispatcher 或 lock）来确保线程安全。 总结与选择 特性 ObservableCollection BindingList 通知机制 集合变更通知 (INotifyCollectionChanged) 支持元素变更通知 (INotifyPropertyChanged) 排序和筛选 需借助 CollectionView 等实现 原生支持排序 适用场景 动态数据绑定，实时 UI 更新 复杂的排序、筛选和 WinForms 数据绑定 性能 在 WPF 中表现优异 较为通用，但在 WPF 中略逊一筹 推荐 使用 ObservableCollection: 如果主要是用于 WPF 中的动态绑定。 使用 BindingList: 如果需要内置排序和属性监听，或者需要兼容 WinForms 应用。 ","date":"2024-11-26T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/observablecollection_and_bindinglist/","title":"ObservableCollection和BindingList对比"},{"content":"隐式索引访问 现在对象初始值设定项表达式中允许隐式“从末尾开始”索引运算符[^]。\n我们来看一个例子，首先创建了一个ImplicitIndex类并且包含一个Numbers属性，该属性是一个长度为 5 的整数数组。\n现在我们可以在初始化类ImplicitIndex时初始化属性Numbers，并使用“从末尾开始”索引运算符来填充数组值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// \u0026lt;summary\u0026gt; /// 隐式索引访问 /// \u0026lt;/summary\u0026gt; private static void TestImplicitIndex() { var implicitIndex = new ImplicitIndex() { Numbers = { [^1] = 5, [^2] = 4, [^3] = 3, [^4] = 2, [^5] = 1 } }; foreach (var item in implicitIndex.Numbers) { Console.WriteLine(item); } } public class ImplicitIndex { public int[] Numbers { get; set; } = new int[5]; } 锁对象 本次更新引入新的锁类型System.Threading.Lock，用于实现互斥。在之前的版本中通常通过object类型进行加锁，而现在有了专门的Lock类型用来加锁。\n新的Lock类型会使得代码更干净、更安全、更高效。\n在新的锁定机制中EnterScope替换了Monitor底层实现。同时它遵循Dispose模式返回ref struct，因此可以与using语句结合使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// \u0026lt;summary\u0026gt; /// 锁对象 /// \u0026lt;/summary\u0026gt; public class LockExample() { private readonly Lock _lock = new Lock(); public void Print() { lock (_lock) { Console.WriteLine(\u0026#34;Lock\u0026#34;); } } } 生成UUID v7 我们经常在实体中使用Guid作为主键，并且通过Guid.NewGuid()可以很方便的生成一个新的Guid，而此方法生成的Guid是依据UUID第四个版本规范生成的。\n当前已经可以通过Guid.CreateVersion7()方法创建UUID第七个版本，这个版本UUID主要功能就是包含了时间戳，数据结构如下：\n| 48位时间戳 | 12位随机 | 62位随机 |\n这也意味着v7版本的UUID可以按时间排序了，在数据库中使用起来更方便，同时Guid.CreateVersion7()方法还有一个重载方法接收DateTimeOffset类型时间戳，用来通过指定时间创建UUID。\n1 2 3 var guid_v4 = Guid.NewGuid(); var guid_v7 = Guid.CreateVersion7(); var guid_v7_time = Guid.CreateVersion7(TimeProvider.System.GetLocalNow()); Linq新方法 CountBy 和 AggregateBy 引入了新的方法 CountBy 和 AggregateBy后，可以在不经过GroupBy 分配中间分组的情况下快速完成复杂的聚合操作，同时方法命名也非常直观，可以大大提升工作效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Student { public string Name { get; set; } public int Age { get; set; } } public void CountByExample() { var students = new List\u0026lt;Student\u0026gt; { new Student { Name = \u0026#34;小明\u0026#34;, Age = 10 }, new Student { Name = \u0026#34;小红\u0026#34;, Age = 12 }, new Student { Name = \u0026#34;小华\u0026#34;, Age = 10 }, new Student { Name = \u0026#34;小亮\u0026#34;, Age = 11 } }; //统计不同年龄有多少人，两个版本实现 //.NET 9 之前 var group = students.GroupBy(x =\u0026gt; x.Age); foreach (var item in group) { Console.WriteLine($\u0026#34;年龄为：{item.Key}，有：{item.Count()} 人。\u0026#34;); } //.NET 9 foreach (var student in students.CountBy(c =\u0026gt; c.Age)) { Console.WriteLine($\u0026#34;年龄为：{student.Key}，有：{student.Value} 人。\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Student { public string Name { get; set; } public string Grade { get; set; } public int Age { get; set; } } public void AggregateByExample() { var students = new List\u0026lt;Student\u0026gt; { new Student { Name = \u0026#34;小明\u0026#34;, Grade = \u0026#34;一班\u0026#34;, Age = 10 }, new Student { Name = \u0026#34;小红\u0026#34;, Grade = \u0026#34;二班\u0026#34;, Age = 12 }, new Student { Name = \u0026#34;小华\u0026#34;, Grade = \u0026#34;一班\u0026#34;, Age = 10 }, new Student { Name = \u0026#34;小亮\u0026#34;, Grade = \u0026#34;二班\u0026#34;, Age = 11 } }; //统计每个班级各自学生总年龄，两个版本实现 //.NET 9 之前 var old = students .GroupBy(stu =\u0026gt; stu.Grade) .ToDictionary(group =\u0026gt; group.Key, group =\u0026gt; group.Sum(stu =\u0026gt; stu.Age)) .AsEnumerable(); foreach (var item in old) { Console.WriteLine($\u0026#34;班级：{item.Key}，总年龄：{item.Value} 。\u0026#34;); } //.NET 9 foreach (var group in students.AggregateBy(c =\u0026gt; c.Grade, 0, (acc, stu) =\u0026gt; acc + stu.Age)) { Console.WriteLine($\u0026#34;班级：{group.Key}，总年龄：{group.Value} 。\u0026#34;); } } ","date":"2024-11-25T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/net9_1/","title":".Net9新特性"},{"content":"Git checkout 签出或切换分支 本章节是对git checkout 命令的介绍。在Git的术语中，“checkout”是指在目标实体的不同版本之间切换的行为。git checkout命令操作三个不同的实体：文件、提交和分支。除了“checkout”的定义之外，短语“签出”通常用于暗示执行git checkout命令的行为。\n在git 撤消更改和提交一篇中，我们看到了如何使用 git checkout 查看旧提交。 本文档大部分内容的重点将是分支的 “checkout” 操作。\n检出分支类似于检出旧的提交和文件，因为工作目录会更新以匹配选定的分支； 但是，新的更改会保存在项目历史记录中——也就是说，它不是只读操作。\n签出分支 git checkout 命令允许我们在 git branch 创建的分支之间进行切换。 签出分支会更新工作目录中的文件以匹配该分支中存储的版本，并告诉 Git 记录该分支上的所有新提交。 将其视为选择你正在从事的开发工作线的一种方式。\n为每个新功能都新建一个专门的分支是对传统 SVN 工作流程的巨大转变。 它使尝试新实验变得非常容易，而不必担心破坏现有功能，并且可以同时处理许多不相关的功能。 此外，分支机构还促进了多个协作工作流程。\ngit checkout 命令有时可能会与 git clone 混淆。 这两个命令之间的区别在于 clone 用于从远程仓库获取代码，或者 checkout 用于在本地系统上已有的代码版本之间切换。\ngit checkout 用法 下面我们看一下 git checkout 常见的两种用法\n已经存在的分支 假设你正在使用的仓库已经创建了几个分支，那么可以使用 git checkout 在这些分支之间进行切换。 要找出哪些分支可用以及当前分支名称是什么，请执行 git branch。\n1 $ git branch 绿色的分支 master 表示的是我们当前所在的活跃分支。下面我们是用 git checkout 命令切换到 jiyik 分支\n1 2 3 $ git checkout jiyik $ git branch 我们看到，现在绿色的分支为 jiyik。说明我们当前切换到了jiyik分支。\n新分支 Git checkout 与 git branch 协同工作。 git branch 命令可用于创建新分支。 当你想开发一个新功能时，可以使用 git branch new_branch 在 master 之外创建一个新分支。 创建后，可以使用 git checkout new_branch 切换到该分支。 此外， git checkout 命令后面可以跟一个 -b 参数，这样就不用使用 git branch命令新建分支了。它会自动创建一个新分支并立即切换到这个分支。 我们可以使用 git checkout 在单个仓库中切换多个功能分支之间进行切换来处理这些功能。\n1 git checkout -b \u0026lt;new-branch\u0026gt; 下面我们使用上面给出的命令创建一个新的分支，首先我们看一下当前有哪些分支\n1 $ git branch 接下来使用git checkout 创建分支并切换到它\n1 2 $ git checkout -b new_branch $ git branch 默认情况下 git checkout -b 将基于当前 HEAD 指向的分支创建新分支。 一个可选的附加分支参数可以传递给 git checkout。\n1 git checkout -b \u0026lt;new-branch\u0026gt; \u0026lt;existing-branch\u0026gt; 在上面的例子中，git checkout 命令后面跟着 参数，然后新分支基于该指定的分支而不是当前 HEAD。\ngit checkout 签出远程分支 与团队合作时，通常使用远程仓库。 这些仓库可能是托管和共享的，也可能是其他同事的本地副本。 每个远程仓库都将包含自己的一组分支。 为了签出远程分支，我们必须首先获取分支的内容。\n1 $ git fetch --all 然后我们看一下本地分支和远程分支的差异\n1 2 $ git branch $ git branch -r 在现代版本的 Git 中，您可以像签出本地分支一样签出远程分支。\n1 $ git checkout jiyik_branch 如果你的Git版本比较旧，则需要使用下面的命令\n1 $ git checkout -b jiyik_branch origin/jiyik_branch 此外，您可以签出一个新的本地分支并将其重置为上次提交的远程分支。这里需要用到 git reset 命令\n1 2 3 $ git checkout -b new_branch $ git reset --hard origin/new_branch HEAD is now at f88bed1 增加迹忆客教程地址 分离 HEAD 状态 现在我们已经看到了 git checkout 在分支上的三个主要用途，讨论“分离的 HEAD”状态很重要。\n记住 - HEAD 是 Git 引用当前快照的方式。\n在内部， git checkout 命令只是更新 HEAD 以指向指定的分支或提交。 当它指向一个分支时，Git 不会有什么变化，但是当你检出一个提交时，它会切换到“分离的 HEAD”状态。\n这是一个警告，告诉我们所做的一切都与项目开发的其余部分“分离”。 如果你在处于“分离的 HEAD 状态”时开始开发功能，则不会有任何分支允许你返回到它。 当不可避免地检查另一个分支（例如，将我们的功能合并到其中）时，将无法引用我们的功能：\ngit checkout分离的HEAD状态\n关键是，你的开发应该总是在一个分支上进行——而不是在一个独立的 HEAD 上。 这确保您始终可以引用新提交。 但是，如果您只是查看旧提交，那么您是否处于分离的 HEAD 状态并不重要。\ngit checkout 总结 本章节主要介绍更改分支时 git checkout 命令的使用。 总之，git checkout 在分支上使用时会改变 HEAD 引用的目标。 它可用于创建分支、切换分支和检出远程分支。 git checkout 命令是标准 Git 操作的必备工具。 它和 git merge 是对应的。 git checkout 和 git merge 命令是启用 git 工作流的关键工具。\n","date":"2024-11-21T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/git_checkout/","title":"Git checkout 签出或切换分支"},{"content":"前言： 俗话说的好工欲善其事必先利其器，Git分布式版本控制系统是我们日常开发中不可或缺的。目前市面上比较流行的Git可视化管理工具有SourceTree、Github Desktop、TortoiseGit，综合网上的一些文章分析和自己的日常开发实践心得个人比较推荐开发者使用SourceTree，因为SourceTree同时支持Windows和Mac，并且界面十分的精美简洁，大大的简化了开发者与代码库之间的Git操作方式。该篇文章主要是对日常开发中使用SourceTree可视化管理工具的一些常用操作进行详细讲解。\nSourceTree | Github Desktop | TortoiseGit 可视化管理工具对比： https://blog.csdn.net/hmllittlekoi/article/details/104504406/\nSourceTree介绍和Atlassian账号注册和登录教程： https://www.cnblogs.com/Can-daydayup/p/13128511.html\n连接Gitee or GitHub，获取代码: 注意：这里介绍的是使用SSH协议获取关联远程仓库的代码，大家也可以直接使用过HTTPS协议的方式直接输入账号密码获取关联代码！\n全面概述Gitee和GitHub生成/添加SSH公钥： https://www.cnblogs.com/Can-daydayup/p/13063280.html\n在SourceTree中添加SSH密钥： 工具=\u0026gt;选择：\n添加SSH密钥位置：C:\\Users\\xxxxx.ssh\\id_rsa.pub：\nSSH客户端选择OpenSSH：\nClone对应托管平台仓库（以Gitee为例）： 打开码云，找到自己需要Clone的仓库！\nSourceTree设置默认工作目录： 由上面我们可以发现每次Clone克隆项目的时候，克隆下来的项目默认存储位置都是在C盘，因此每次都需要我们去选择项目存放的路径，作为一个喜欢偷懒的人而言当然不喜欢这种方式啦，因此我们可以设置一个默认的项目存储位置。\n设置SourceTree默认项目目录： 点击工具=\u0026gt;选项=\u0026gt;一般=\u0026gt;找到项目目录设置Clone项目默认存储的位置：\nSourceTree代码提交： 首先切换到需要修改功能代码所在的分支： 将修改的代码提交到暂存区： 将暂存区中的代码提交到本地代码仓库： 注意：多人同时开发项目的时候，不推荐默认选中立即推送变更到origin/develop，避免一些不必要的麻烦！\n代码拉取更新本地代码库，并将代码推送到远程仓库： 勾选需要推送的分支，点击推送到远程分支：\n代码成功推送到远程代码库：\n在Gitee中查看推送结果： SourceTree分支切换，新建，合并： 分支切换： 双击切换：\n单击鼠标右键切换：\n新建分支： 注意：在新建分支时，我们需要在哪个主分支的基础上新建分支必须先要切换到对应的主分支才能到该主分支上创建分支，如下我们要在master分支上创建一个feature-0613分支：\n合并分支: *注意：在合并代码之前我们都需要将需要合并的分支拉取到最新状态（*避免覆盖别人的代码，或者丢失一些重要文件）!!!\n在master分支上点击右键，选择合并feature-0613至当前分支即可进行合并:\n分支合并成功：\nSourceTree代码冲突解决： 首先我们需要制造一个提交文件遇到冲突的情景： 在SoureceTree中在Clone一个新项目，命名为pingrixuexilianxi2，如下图所示：\n我们以项目中的【代码合并冲突测试.txt】文件为例：\n在pingrixuexilianxi2中添加内容，并提交到远程代码库，添加的内容如下：\n在pingrixuexilianxi中添加内容，提交代码（不选择立即推送变更到origin/master），拉取代码即会遇到冲突：\n冲突文件中的内容：\n直接打开冲突文件手动解决冲突： 由下面的冲突文件中的冲突内容我们了解到：\n1 2 `\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD``6月19日 pingrixuexilianxi添加了内容``=======``6月18日 pingrixuexilianxi2修改了这个文件哦``\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; a8284fd41903c54212d1105a6feb6c57292e07b5` `\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD到 =======里面的【6月19日 pingrixuexilianxi添加了内容】是自己刚才的Commit提交的内容``=======到 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; a8284fd41903c54212d1105a6feb6c57292e07b5里面的【6月18日 pingrixuexilianxi2修改了这个文件哦】是远程代码库更新的内容（即为pingrixuexilianxi2本地代码库推送修改内容）。` 手动冲突解决方法：\n根据项目需求删除不需要的代码就行了，假如都需要的话我们只需要把 \u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD======= \u0026raquo;\u0026raquo;\u0026raquo;\u0026gt; a8284fd41903c54212d1105a6feb6c57292e07b5都删掉冲突就解决了（注意，在项目中最后这些符号都不能存在，否则可能会报异常）。\n最后将冲突文件标记为已解决，提交到远程仓库：\n采用外部文本文件对比工具Beyond Compare解决冲突: SourceTree配置文本文件对比工具Beyond Compare: 工具=\u0026gt;选项=\u0026gt;比较：\n使用Beyond Compare解决冲突： Beyond Compare使用技巧：\n官方全面教程：https://www.beyondcompare.cc/jiqiao/\nSourceTree打开外部和合并工具：\n注意：第一次启动Beynod Compare软件需要一会时间，请耐心等待：\n******\nBeynod Compare进行冲突合并：\n点击保存文件后关闭Beynod Compare工具，SourceTree中的冲突就解决了，在SourceTree中我们会发现多了一个 .orig 的文件。接着选中那个.orig文件，单击右键 =\u0026gt; 移除，最后我们推送到远程代码库即可：\nSourcetree中的基本名词说明： 克隆/新建(clone)：从远程仓库URL加载创建一个与远程仓库一样的本地仓库。\n提交(commit)：将暂存区文件上传到本地代码仓库。\n推送(push)：将本地仓库同步至远程仓库，一般推送（push）前先拉取（pull）一次，确保一致（十分注意：这样你才能达到和别人最新代码同步的状态，同时也能够规避很多不必要的问题）。\n拉取(pull)：从远程仓库获取信息并同步至本地仓库，并且自动执行合并（merge）操作（git pull=git fetch+git merge）。\n获取(fetch)：从远程仓库获取信息并同步至本地仓库。\n分支(branch)：创建/修改/删除分枝。\n合并(merge)：将多个同名文件合并为一个文件，该文件包含多个同名文件的所有内容，相同内容抵消。\n贮藏(git stash)：保存工作现场。\n丢弃(Discard)：丢弃更改,恢复文件改动/重置所有改动,即将已暂存的文件丢回未暂存的文件。\n标签(tag)：给项目增添标签。\n工作流(Git Flow)：团队工作时，每个人创建属于自己的分枝（branch）��确定无误后提交到master分支。\n终端(terminal)：可以输入git命令行。\n每次拉取和推送的时候不用每次输入密码的命令行：git config credential.helper osxkeychain sourcetree。\n检出(checkout)：切换不同分支。\n添加（add）：添加文件到缓存区。\n移除（remove）：移除文件至缓存区。\n重置(reset)：回到最近添加(add)/提交(commit)状态。\nGit分布式版本控制器常用命令和使用： 当然作为一个有逼格的程序员， 一些常用的命令我们还是需要了解和掌握的，详情可参考我之前写过的文章：\nhttps://www.cnblogs.com/Can-daydayup/p/10134733.html\nSourceTree如何提交PR(Pull Request)： Pull Request提交相关操作参考该篇文章：\nhttps://www.jianshu.com/p/b365c743ec8d\nfork 项目： 克隆本地 打开Git Bash输入仓库克隆命令：\n1 git clone https://github.com/liangtongzhuo/taro-ui.git 根据文档创建分支 拖进 SourceTree，基于 dev 创建分支如下图：\n提交修改的代码到远程代码库 文章上面已经提到了使用SourceTree提交的相关操作，可参考：\nhttps://www.cnblogs.com/Can-daydayup/p/13128633.html#_label5（或者Ctrl F：SourceTree代码提交）\n当然也可以使用git命令提交：\n1 `git add . --提交所有修改的文件到本地暂存区``git commit -m\u0026#34;fix(dos):修正文字 \u0026#34; --提交到本地代码库``git push --提交到github中的远程代码库` 提交 Pull Request 第四步提交成功后，进入原来fork的仓库，点击 Compare\n提交你的说明，选择合并的分支即可，剩下等待合并。\n","date":"2024-11-15T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/gitskill/","title":"SourceTree使用教程"},{"content":"C#12 中的集合表达式 经典集合初始化器 自 C# 3.0 起，我们就有了 “集合初始化器” 。它们采用 {} 模式来初始化任何实现了 Add() 方法的 IEnumerable 实现。例如，这会创建一个新的 List\u0026lt;string\u0026gt; 并用 5 个值初始化它：\n1 var values = new List\u0026lt;string\u0026gt; { \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34; }; 幕后，编译器生成的代码看起来像这样：\n1 2 3 4 5 6 List\u0026lt;string\u0026gt; values = new List\u0026lt;string\u0026gt;(); values.Add(\u0026#34;1\u0026#34;); values.Add(\u0026#34;2\u0026#34;); values.Add(\u0026#34;3\u0026#34;); values.Add(\u0026#34;4\u0026#34;); values.Add(\u0026#34;5\u0026#34;); C# 中的数组初始化有其特别之处，你可以用比其他集合更多的方法来初始化它们，尽管看起来与标准集合初始化器相似：\n1 2 3 var values1 = new[] { \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34; }; var values2 = new string[4] { \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34; }; string[] values3 = { \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34; }; 这些工作方式与集合初始化器不同；这里没有调用 Add() 方法。相反，编译器生成的是如果你手动做这一切时同样的初始化代码：\n1 2 3 4 5 string[] array = new string[4]; array[0] = \u0026#34;1\u0026#34;; array[1] = \u0026#34;2\u0026#34;; array[2] = \u0026#34;3\u0026#34;; array[3] = \u0026#34;4\u0026#34;; 我们已经讨论了通用集合（如 List ）和数组的集合初始化器，还有在 Span 世界中变得更为有用的 stackalloc 表达式，因为不需要使用 unsafe 代码：\n1 Span\u0026lt;int\u0026gt; array = stackalloc []{ 1, 2, 3, 4 }; 幕后，编译器将这个 stackalloc 初始化器转化为一些类似这样的 unsafe 代码：\n1 2 3 4 5 6 7 8 unsafe { byte* num = stackalloc byte[16]; *(int*)num = 1; *(int*)(num + 4) = 2; *(int*)(num + (nint)2 * (nint)4) = 3; *(int*)(num + (nint)3 * (nint)4) = 4; Span\u0026lt;int\u0026gt; array = new Span\u0026lt;int\u0026gt;(num, 4); } 这段代码在栈上创建了一个数组，然后通过指针运算遍历每个元素，设置每个值。\n使用集合表达式统一语法 我们已经看到至少有三种不同的场景下我们在初始化集合：\n数组 类似 List 的集合 使用 stackalloc 的 ReadOnlySpan 每种情况都需要稍微不同的语法，例如：\n1 2 3 4 int[] array = new[] { 1, 2, 3, 4 }; List\u0026lt;int\u0026gt; list = new() { 1, 2, 3, 4 }; HashSet\u0026lt;int\u0026gt; hashset = new() { 1, 2, 3, 4 }; ReadOnlySpan\u0026lt;int\u0026gt; span = stackalloc [] { 1, 2, 3, 4 }; 这有点混乱和烦人。C#12 中引入的集合表达式提供了一种简化、统一的语法，适用于所有这些不同的集合类型。例如：\n1 2 3 4 int[] array = [1, 2, 3, 4] List\u0026lt;int\u0026gt; list = [1, 2, 3, 4]; HashSet\u0026lt;int\u0026gt; hashset = [1, 2, 3, 4]; ReadOnlySpan\u0026lt;int\u0026gt; span = [1, 2, 3, 4]; 集合表达式在所有集合类型上的一致性是一个真正的优势，但这并不是唯一的优点。集合表达式相比集合初始化器可以提供性能优势（我们将在后续文章中探讨），以及额外的功能。\n推断接口类型 想象一下，你想要创建一个集合，但你只关心它实现了 IEnumerable 。你需要自己决定使用哪个后端类型：\n1 2 3 IEnumerable\u0026lt;int\u0026gt; list1 = new List\u0026lt;int\u0026gt; { 1, 2, 3, 4 }; IEnumerable\u0026lt;int\u0026gt; list2 = new HashSet\u0026lt;int\u0026gt; { 1, 2, 3, 4 }; IEnumerable\u0026lt;int\u0026gt; list3 = new int[] { 1, 2, 3, 4 }; 那么应该选择哪一个呢？如果所有你需要做的就是枚举列表，那理论上选择哪种类型都不应该重要，对吧？那么正确的选项是什么？\n使用集合表达式，你可以将此决策委托给编译器。你可以不指定后端类型，而由编译器来决定。而且，集合表达式的额外优点是更加简洁：\n1 2 3 IEnumerable\u0026lt;int\u0026gt; ienumerable = [1, 2, 3, 4]; IList\u0026lt;int\u0026gt; ilist = [1, 2, 3, 4]; IReadOnlyCollection\u0026lt;int\u0026gt; icollection = [1, 2, 3, 4]; 幕后，编译器完全透明地创建了一个实现所需接口的集合，所以你无需考虑这一点。\n值得注意的是，虽然编译器会自动为接口集合选择一个具体的类型，但你需要指定某种类型。例如，你不能使用 var ：\n1 2 3 4 var values = [1, 2, 3, 4]; // ❌ 编译错误，CS9176：集合表达式没有目标类型 Sum(values); Sum([1, 2, 3, 4]); // ✅ 这是可行的 int Sum(IEnumerable\u0026lt;int\u0026gt; v) =\u0026gt; v.Sum(); 问题在于，根据 C#编译器的工作方式，它无法推断 values 的类型应为 IEnumerable\u0026lt;int\u0026gt; ，因此抛出了错误。未来版本的 C#可能会改变这种情况，但可能的解决方案是始终选择 int[] ，这并不一定是最优的，所以不要抱太大希望。\n针对 ReadOnlySpan 的高效自动 stackalloc 对于 ReadOnlySpan 和 Span 实例来说，如果你只使用集合初始化器，情况也类似。如果你只需要在 Span 或 ReadOnlySpan 中存储一些数据，那么使用集合初始化器就需要决定将数据放在哪里，然后再从中获取 Span：\n1 2 3 Span\u0026lt;int\u0026gt; spans2 = stackalloc[] { 1, 2, 3, 4 }; // 栈上分配数组 Span\u0026lt;int\u0026gt; spans3 = new[] { 1, 2, 3, 4 }; // 在堆上分配 Span\u0026lt;string\u0026gt; spans4 = new[] { \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34; }; // 不能直接使用 stackalloc 分配字符串数组 虽然这不是一个很大的决策，通常只有两个合理的选择，但还是需要额外考虑的事情。此外，你不能直接使用 stackalloc 为 string[] 分配内存，除非通过一些 InlineArray 的技巧 。\n使用集合表达式，你可以再次将此决策委托给编译器，它会做出正确的处理。\n1 2 ReadOnlySpan\u0026lt;int\u0026gt; readonlyspans = [1, 2, 3, 4]; Span\u0026lt;string\u0026gt; spans = [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;]; 在系列的后续部分，你会发现这些特定的集合表达式案例被高度优化！\n集合表达式使重构更简单 到目前为止，我展示的所有例子都是将集合表达式赋值给变量，但实际上你也可以直接将集合表达式作为方法参数使用，比如：\n1 2 3 4 5 6 7 8 using System.Linq; using System.Collections.Generic; // 创建一个接受IEnumerable\u0026lt;int\u0026gt;的方法 int Sum(IEnumerable\u0026lt;int\u0026gt; values) =\u0026gt; values.Sum(); // 使用集合表达式调用方法 Sum([1, 2, 3, 4]); 这种模式的一个好处是，如果我改变了 Sum() 的签名，我不需要改变调用站点。相比之下，如果你使用集合初始化器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 如果方法接受数组... int Sum1(int[] values) =\u0026gt; values.Sum(); Sum1(new [] { 1, 2, 3, 4 }); // 必须使用数组语法 // 如果方法接受IEnumerable... int Sum2(IEnumerable\u0026lt;int\u0026gt; values) =\u0026gt; values.Sum(); Sum2(new List\u0026lt;int\u0026gt; { 1, 2, 3, 4 }); // 必须使用显式类型，如List或类似 // 如果方法接受ReadOnlySpan... int Sum3(ReadOnlySpan\u0026lt;int\u0026gt; values) { var total = 0; foreach (var value in values) { total += value; } return total; } Sum3(new []{ 1, 2, 3, 4 }); // 必须选择标准数组或者使用stackalloc分配的数组 如果使用集合表达式，那么我们可以使用完全相同的语法来调用所有三个 Sum() 实现：\nSum1([ 1, 2, 3, 4 ]); Sum2([ 1, 2, 3, 4 ]); Sum3([ 1, 2, 3, 4 ]);\n并且，编译器会使用最有效的实现方式来创建所需类型的集合。\n这看起来可能是一件小事，而且在某种程度上确实是这样，但正是所有这些小小的便利特性使得集合表达式成为一个非常整洁的功能！整体而言，正是这些微小的方便性让集合表达式的使用变得极为顺手和高效。\n空集合 在 C# 中，集合表达式的一个特性是编译器明确识别空集合的语法。这意味着你不再需要写像下面这样的代码：\n1 2 var empty = new int[]{}; // 通常你不应该这样做... var empty = Array.Empty\u0026lt;int\u0026gt;(); // ...相反，更倾向于使用这行代码! 现在，你可以使用 [] 来生成一个适当的空集合版本，例如：\n1 int[] empty = []; 集合表达式相比于显式初始化有两大主要优势：\n编译器可以选择创建空集合的最有效方式，比如选择 Array.Empty()（或其等价方法）。 对于所有集合类型，你可以使用一致的语法。 以下示例展示了多种集合类型，以及如何使用 [] 来创建它们的空版本。每行代码后的注释显示了编译器为特定类型生成的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 int[] array = []; // Array.Empty() HashSet\u0026lt;int\u0026gt; hashset = []; // new HashSet\u0026lt;int\u0026gt;() List\u0026lt;int\u0026gt; list = []; // new List\u0026lt;int\u0026gt;() IEnumerable\u0026lt;int\u0026gt; ienumerable = []; // Array.Empty() ICollection\u0026lt;int\u0026gt; icollection = []; // new List\u0026lt;int\u0026gt;() IList\u0026lt;int\u0026gt; ilist = []; // new List\u0026lt;int\u0026gt;() IReadOnlyCollection\u0026lt;int\u0026gt; readonlycollection = []; // Array.Empty() IReadOnlyList\u0026lt;int\u0026gt; readonlyList = []; // Array.Empty() Span\u0026lt;int\u0026gt; span = []; // default(Span\u0026lt;int\u0026gt;) ReadOnlySpan\u0026lt;int\u0026gt; readonlyspan = []; // default(ReadOnlySpan\u0026lt;int\u0026gt;) ImmutableArray\u0026lt;int\u0026gt; immutablearray = []; // ImmutableArray.CreateRange(Array.Empty()) ImmutableList\u0026lt;int\u0026gt; immutablelist = []; // ImmutableList.Create(default(ReadOnlySpan\u0026lt;int\u0026gt;)); 如你所见，编译器尽可能地高效；如果类型是可变的，如 HashSet 或 List，那么它只能创建一个新的实例；但如果可以使用不分配内存的版本，如 Array.Empty()，那么它就会采用这种方式！请注意，在最后一个示例中，ImmutableArray 和 ImmutableList 使用了不同的构造函数来创建空集合，因为它们是不可变集合。\n使用展开运算符（spread element）从其他集合构建集合 我们已经了解了集合表达式的两个好处：\n一致的语法 高效的编译器生成实现 集合表达式的另一个重要特性是 展开运算符 (..)。这使你能够更容易地从其他集合实例构建新的集合。\n举个具体的例子，假设你有两个 IEnumerable 集合，并且你想将它们作为数组连接起来。使用 LINQ，这是相当容易做到的，因为它提供了专门用于此类操作的扩展方法：\n1 2 3 4 int[] ConcatAsArray(IEnumerable\u0026lt;int\u0026gt; first, IEnumerable\u0026lt;int\u0026gt; second) { return first.Concat(second).ToArray(); } 很好，但是如果现在你需要处理的是 ReadOnlySpan 而不是 IEnumerable 呢？不幸的是，正如我们之前讨论的那样，ReadOnlySpan 不实现 IEnumerable 接口，所以我们可能需要这样做：\n1 2 3 4 5 6 7 int[] ConcatAsArray(ReadOnlySpan\u0026lt;int\u0026gt; first, ReadOnlySpan\u0026lt;int\u0026gt; second) { var list = new List\u0026lt;int\u0026gt;(first.Length + second.Length); list.AddRange(first); list.AddRange(second); return list.ToArray(); } 这虽然不是 糟糕，但仍然让人感到恼火，因为对于每种不同的集合类型都得考虑这些细节。而使用集合表达式和展开运算符，我们得到了一个简洁的快捷方式，它可以用于所有受支持的集合类型。上述两种重载都可以用同样的方式实现：\n1 2 int[] ConcatAsArray(IEnumerable\u0026lt;int\u0026gt; first, IEnumerable\u0026lt;int\u0026gt; second) =\u0026gt; [..first, ..second]; int[] ConcatAsArray(ReadOnlySpan\u0026lt;int\u0026gt; first, ReadOnlySpan\u0026lt;int\u0026gt; second) =\u0026gt; [..first, ..second]; 而且，由于集合表达式的一致性，如果你更改 ConcatAsArray() 方法的参数 或者 返回类型，你完全不需要修改集合表达式本身，它依旧可以正常工作！\n.. 运算符意味着 “写出集合中的所有值” ，因此再举一个例子：\n1 2 3 4 int[] array = [1, 2, 3, 4]; IEnumerable\u0026lt;int\u0026gt; oddValues = array.Where(int.IsOddInteger); // 1, 3 int[] evenValues = [..array.Where(int.IsEvenInteger)]; // 2, 4 int[] allValues = [..oddValues, ..evenValues]; // 1, 3, 2, 4 上述代码多次使用了展开运算符，但在每种情况下，它都意味着 “写出集合的所有元素” 。所以在最后一步中，allValues 包含了 oddValues 中的所有元素，后面跟着 evenValues 中的所有值。\n你也可以在集合表达式中混合单一值和展开集合，例如：\n1 2 int[] arr = [1, 2, 3, 4]; int[] myValues = [0, ..arr, 5, 6]; // 0, 1, 2, 3, 4, 5, 6 最终结果就像是遍历了 arr 并添加了每个值一样。\n注意，展开运算符 .. 与 范围运算符（如 1..3 或 2..^ 中的 ..）是 不同 的，后者用于对数组进行 索引。然而，你可以结合使用它们，先用 范围 来选择元素子集，然后将它们 展开 到集合表达式中：\n1 2 int[] primes = [1, 2, 3, 5, 7, 9, 11]; int[] some = [0, ..primes[1..^1]]; // 0, 2, 3, 5, 7, 9 这段代码使用 1..^1 范围运算符取 primes 数组的第1个至N-1个元素（即 2, 3, 5, 7, 9），然后在集合表达式中使用展开 ..。\n集合表达式为创建集合添加了一种很好的对称性（在重构从一种集合类型到另一种时特别有用），并且通过展开运算符使集合的组合变得更加简单。但集合表达式不仅仅是关于语法。重要的是，集合表达式为编译器提供了优化其生成代码的选项。\n在下一篇中，我们将探讨更多类型的集合，如 T[] 和 ReadOnlySpan\u0026lt;T\u0026gt;，看看它们在使用集合表达式时是如何被高度优化的。\n英文原文\n","date":"2024-11-14T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/collection-expressions/","title":"C#12 中的集合表达式"},{"content":"常见的数据结构包括数组、链表、栈、队列、树和图等。每种数据结构都有其特定的优势和应用场景。例如，数组适用于索引访问和快速查找，链表适用于插入和删除操作频繁的情况，树适用于层次结构数据的表示和搜索，图适用于表示复杂的关系网络等。 1、数组 数组是将具有相同类型的若干变量有序地组织在一起的集合，可以说是最基本的数据结构。\n优点： （1）按照索引查询元素的速度很快；\n（2）按照索引遍历数组也很方便。\n缺点： （1）数组的大小在创建后就确定了，无法扩容：定义（初始化）必须给定数据的大小；\n（2）数组只能存储一种类型的数据；\n（3）添加、删除元素的操作很耗时间，因为要移动其他元素。\n2、栈（电梯） 栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照先进后出或后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。 栈的操作规则：后进先出\n3、队列（食堂排队） 队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。\n队列的操作规则：先进先出 为了提高队列的利用率，采用循环队列来存储数据循环队列: rear 加到 顶时 回来。\n4、链表 链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。\n链表分为单向链表、双向链表和循环列表。\n1）单向链表\n前面的黄色方块代表数据域，后面蓝色方块是指针域。\n2）双向链表 p代表prev，N代表next。\n3）单向循环链表\nh是头结点，p是定义的一个指针\n单向链表的缺点是只能从头到尾依次遍历，而双向链表可进可退，既能找到下一个，也能找到上一个，每个节点上都需要多分配一个存储空间。\n5、树 树是一种数据结构，它是由n（n\u0026gt;=1）个有限节点组成一个具有层次关系的集合。树是典型的非线性结构，在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点。\n二叉树 二叉树特点:\n二叉树第i（i≥1）层上的节点最多为2^i-1个 深度为k（k≥1）的二叉树最多有2^k - 1个节点 在任意一棵二叉树中，树叶的数目比度数为2的节点的数目多1 二叉树遍历 二叉树中还包括满二叉树和完全二叉树。\n满二叉树 ：深度为k（k≥1）时有2k－1个节点的二叉树。\n完全二叉树 ：只有最下面两层有度数小于2的节点，且最下面一层的叶节点集中在最左边的若干位置上。\n完全二叉树的判断\n6、图 图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。\n图分为有向图和无向图：\n有向图：边不仅连接两个顶点，并且具有方向； 无向图：边仅仅连接两个顶点，没有其他含义；\n7、堆 堆（heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：\n堆中某个结点的值总是不大于或不小于其父结点的值； 堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。\n大根堆\n小根堆\n8、散列表（哈希表）（字典） 散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。\n哈希查找有3个概念\n1 、关键字 (key)\n2 、计算公司(哈希函数 又称为 散列函数)\n3 、存储数据的表 (哈希表又称为 散列表)\n算法(哈希函数)：\n直接寻址法：取关键字或关键字的某个线性函数值为散列地址。 数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。 平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。 取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。 除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。\n","date":"2024-11-14T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/common-collection/","title":"常用数据结构"},{"content":" 写Mrakdown费事？Typora让你像写Word一样行云流水，所见即所得。\n简介 Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。\nTypora删除了预览窗口，以及所有其他不必要的干扰。取而代之的是实时预览。 Markdown的语法因不同的解析器或编辑器而异，Typora使用的是GitHub Flavored Markdown。 Markdown介绍 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nMarkdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md, .markdown。\n常用快捷键 加粗： Ctrl + B 标题： Ctrl + H 插入链接： Ctrl + K 插入代码： Ctrl + Shift + C \u0026ndash; 无法执行 行内代码： Ctrl + Shift + K 插入图片： Ctrl + Shift + I 无序列表：Ctrl + Shift + L \u0026ndash; 无法执行 撤销： Ctrl + Z 一级标题： Ctrl + 1 \u0026ndash; 以此类推 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Typora快捷键整合 ``` Ctrl+1 一阶标题 Ctrl+B 字体加粗 Ctrl+2 二阶标题 Ctrl+I 字体倾斜 Ctrl+3 三阶标题 Ctrl+U 下划线 Ctrl+4 四阶标题 Ctrl+Home 返回Typora顶部 Ctrl+5 五阶标题 Ctrl+End 返回Typora底部 Ctrl+6 六阶标题 Ctrl+T 创建表格 Ctrl+L 选中某句话 Ctrl+K 创建超链接 Ctrl+D 选中某个单词 Ctrl+F 搜索 Ctrl+E 选中相同格式的文字 Ctrl+H 搜索并替换 Alt+Shift+5 删除线 Ctrl+Shift+I 插入图片 Ctrl+Shift+M 公式块 Ctrl+Shift+Q 引用 注：一些实体符号需要在实体符号之前加”\\”才能够显示 ``` 块元素 换行符 在markdown中，段落由多个空格分隔。在Typora中，只需回车即可创建新段落。\n标题级别 # 一级标题 快捷键为 Ctrl + 1\n## 二级标题 快捷键为 Ctrl + 2\n\u0026hellip;\u0026hellip;\n###### 六级标题 快捷键为 Ctrl + 6\n引用文字 \u0026gt; + 空格 + 引用文字\n无序列表 使用 * + - 都可以创建一个无序列表\nAAA BBB CCC 有序列表 使用 1. 2. 3. 创建有序列表\nAAA BBB CCC 任务列表 \\ -[ ] 不勾选\n\\ -[x] 勾选\n代码块 在Typora中插入程序代码的方式有两种：使用反引号 `（~ 键）、使用缩进（Tab）。\n插入行内代码，即插入一个单词或者一句代码的情况，使用 code 这样的形式插入。 插入多行代码输入3个反引号（`） + 回车，并在后面选择一个语言名称即可实现语法高亮。 1 2 def helloworld(): print(\u0026#34;hello, world!\u0026#34;) 数学表达式 当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。根据需要加载 Mathjax 对数学公式进行渲染。\n按下 $$，然后按下回车键，即可进行数学公式的编辑。\n1 2 3 $$ \\mathbf{V}_1\\times\\mathbf{V}_2 = \\mathbf{X}_3 $$ 插入表格 输入 | 表头1 | 表头2 |并回车。即可创建一个包含2列表。快捷键 Ctrl + T弹出对话框。\nid number 不管是哪种方式，第一行为表头，第二行为分割表头和主体部分，第三行开始每一行为一个表格行\n列与列之间用管道符号 | 隔开\n还可设置对齐方式(表头与内容之间)，如果不使用对齐标记，内容默认左对齐，表头居中对齐\n左对齐 ：| 右对齐 |： 中对齐 ：|： 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界\n为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。\n脚注 这个例子的脚注为[1]。\n注意：该例子脚注标识是1，脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文。\n分割线 输入 *** 或者 --- 再按回车即可绘制一条水平线，如下：\n目录（TOC） 输入 [ toc ] 然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。\nTypora支持TOC自动生成目录，博客园不支持？\n目录\n简介 Markdown介绍 常用快捷键 块元素 换行符 标题级别 引用文字 无序列表 有序列表 任务列表 代码块 数学表达式 插入表格 脚注 分割线 目录（TOC） 跨度元素 链接 内部链接 参考链接 网址 图片 斜体 加粗 加粗斜体 代码标记 删除线 下划线 表情符号 下标 上标 高亮 文本居中 换行符 转义 HTML 嵌入内容 视频 总结 跨度元素 跨度元素即图片，网址，视频等，在Typora中输入后，会立即载入并呈现。\n链接 内部链接 这是一个带有标题属性的 [链接](http://example.com/ \u0026quot;标题\u0026quot;)\n这是一个没有标题属性的 [链接](http://example.net/)\n链接\n链接\n参考链接 这是一个[参考链接]id \u0026ndash; 无法执行\n网址 Typora允许用\u0026lt;括号括起来\u0026gt;, 把URL作为链接插入。\nTypora还会自动链接标准网址。\nwww.baidu.com\n图片 ![显示的文字](C:\\Users\\Hider\\Desktop\\echart.png \u0026quot;图片标题\u0026quot;)\n![显示的文字](C:\\Users\\Hider\\Desktop\\echart.png)\n除了以上2种方式之外，还可以直接将图片拖拽进来，自动生成链接。\n斜体 使用 *单个星号* 或者 _单下划线_ 可以字体倾斜。快捷键 Ctrl + I\n斜体\n加粗 使用 **两个星号** 或者 __两个下划线__ 可以字体加粗。快捷键 Ctrl + B\n加粗\n加粗斜体 使用***加粗斜体***可以加粗斜体。\n加粗斜体\n代码标记 标记代码使用反引号，即在英文输入法下，ESC键下面和1键左边的符号。\n使用该 printf()功能\n删除线 使用~~删除线~~ 快捷键 Alt + Shift + 5\n删除线\n下划线 \\下划线 \u0026ndash; 无法执行\n参考另一篇文章，可执行。\n通过\u0026lt;u\u0026gt;下划线的内容\u0026lt;/u\u0026gt; 或者 快捷键Ctrl + U可实现下划线\n下划线的内容\n表情符号 Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。\n:smile \u0026ndash; 无法显示\n😺\n下标 可以使用 \u0026lt;sub\u0026gt;文本\u0026lt;/sub\u0026gt;实现下标。\n(需在设置中打开该功能)\nH2O\nH2O\n上标 可以使用\u0026lt;sup\u0026gt;文本\u0026lt;/sup\u0026gt;实现上标。\n(需在设置中打开该功能)\nX2\nX2\n高亮 ==高亮==(需在设置中打开该功能)\n==我是最重要的==\n文本居中 使用 \u0026lt;center\u0026gt;这是要居中的内容\u0026lt;/center\u0026gt;可以使文本居中\n这是要居中的文本内容\n换行符 使用 空格 + 空格 + Enter可以实现换行，例如：\n或者可以使用\u0026lt;br/\u0026gt;实现换行。\n转义 Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n文本加粗\n** 正常显示星号 **\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n1 2 3 4 5 6 7 8 9 10 11 12 \\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号 HTML 支持HTML\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n目前支持的 HTML 元素有：\u0026lt;kbd\u0026gt; \u0026lt;b\u0026gt; \u0026lt;i\u0026gt; \u0026lt;em\u0026gt; \u0026lt;sup\u0026gt; \u0026lt;sub\u0026gt; \u0026lt;br\u0026gt;等 ，如：\n1 2 使用 \u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt; 重启电脑 \u0026lt;kbd\u0026gt; \u0026lt;/kbd\u0026gt; -- 白色框框 效果：\n使用 Ctrl+Alt+Del 重启电脑\n嵌入内容 视频 总结 建议打开大纲视图Ctrl + Shift + 1 插入表格需要顶格写，否则无法显示 语法无须刻意记忆，右键可查询 参考链接1：Typora入门（中文版）\n参考链接2：Typora\n参考链接3：Markdown代码块与语法高亮\n参考链接4：Markdown使用-表格及其居中等格式\n参考链接5：Markdown语法小结\n参考链接6：Runoob：Markdown教程\n","date":"2024-10-12T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/typora_1/","title":"Typora入门"},{"content":"在C#中，静态构造函数（也称为类型构造函数）是一种特殊的构造函数，用于初始化静态成员或执行只需要一次的操作。静态构造函数的主要特点包括：\n无需显式调用：静态构造函数在第一次访问类型的静态成员或实例成员之前，由运行时自动调用。\n不能有访问修饰符：静态构造函数不能有public、private等访问修饰符。它只能由类型定义来确定。\n无参数：静态构造函数不能有参数。\n每个类型只能有一个静态构造函数。\n不能通过对象实例来调用：静态构造函数只能通过类型本身触发，而不能通过类型的实例来触发。\n下面是一个简单的示例，展示了如何使用静态构造函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 using System; class MyClass { // 静态字段 public static int StaticField; // 静态构造函数 static MyClass() { Console.WriteLine(\u0026#34;静态构造函数被调用\u0026#34;); StaticField = 42; } // 实例构造函数 public MyClass() { Console.WriteLine(\u0026#34;实例构造函数被调用\u0026#34;); } // 静态方法 public static void StaticMethod() { Console.WriteLine(\u0026#34;静态方法被调用\u0026#34;); } } class Program { static void Main() { // 访问静态字段，触发静态构造函数 Console.WriteLine(MyClass.StaticField); // 创建实例，静态构造函数不会再次被调用 MyClass myClass = new MyClass(); // 调用静态方法 MyClass.StaticMethod(); } } 输出：\n1 2 3 4 静态构造函数被调用 42 实例构造函数被调用 静态方法被调用 在这个示例中，MyClass类定义了一个静态字段StaticField和一个静态构造函数。在Main方法中，第一次访问StaticField时，静态构造函数被调用并初始化了StaticField。随后的实例创建和静态方法调用不会再次触发静态构造函数。\n静态构造函数通常用于执行类型级别的初始化任务，例如设置静态字段的默认值、配置类型级别的资源等。它保证这些初始化逻辑在类型首次使用时恰当地执行。\n","date":"2024-09-27T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/static_constructors/","title":"C#静态构造函数"},{"content":"内存泄漏（Memory Leak）是指程序无法释放已经不再使用的内存，从而导致内存消耗不断增加，最终可能耗尽系统内存资源。尽管C#具有垃圾回收机制（Garbage Collection，简称GC），能够自动管理内存，但某些情况下仍可能出现内存泄漏。内存泄漏在C#中通常不是由于忘记释放内存，而是由于程序中存在对不再需要的对象的引用，导致这些对象无法被GC回收。\n常见导致内存泄漏的情况 事件处理器未解除订阅 如果对象A订阅了对象B的事件，但在对象A销毁时未解除订阅，对象B将持有对对象A的引用，导致对象A无法被垃圾回收。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Publisher { public event EventHandler MyEvent; } public class Subscriber { public Subscriber(Publisher pub) { pub.MyEvent += HandleEvent; } private void HandleEvent(object sender, EventArgs e) { // Event handler code } public void Unsubscribe(Publisher pub) { pub.MyEvent -= HandleEvent; } } 静态变量持有引用 静态变量的生命周期与应用程序相同，如果静态变量持有对象引用，这些对象将无法被垃圾回收。\n1 2 3 4 5 6 7 8 9 public class MyClass { private static List\u0026lt;object\u0026gt; staticList = new List\u0026lt;object\u0026gt;(); public void AddObject(object obj) { staticList.Add(obj); } } 未能正确处理IDisposable对象 对于实现了IDisposable接口的对象，未能在使用后正确调用Dispose方法会导致资源未释放。\n1 2 3 4 5 6 public void ProcessData() { var stream = new FileStream(\u0026#34;data.txt\u0026#34;, FileMode.Open); // Use the stream // Forgot to call stream.Dispose() } 长时间存在的对象引用 长时间存在的集合或缓存未能清理，导致大量对象无法被回收。\n1 2 3 4 5 6 7 8 9 public class Cache { private static Dictionary\u0026lt;string, object\u0026gt; cache = new Dictionary\u0026lt;string, object\u0026gt;(); public static void AddToCache(string key, object value) { cache[key] = value; } } 避免内存泄漏的方法 及时解除事件订阅 在不再需要事件处理时，及时解除订阅。\n1 2 3 4 public void Unsubscribe(Publisher pub) { pub.MyEvent -= HandleEvent; } 使用弱引用（WeakReference） 对于缓存或长时间存在的引用，使用WeakReference可以允许GC回收不再使用的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private static Dictionary\u0026lt;string, WeakReference\u0026gt; cache = new Dictionary\u0026lt;string, WeakReference\u0026gt;(); public static void AddToCache(string key, object value) { cache[key] = new WeakReference(value); } public static object GetFromCache(string key) { if (cache.TryGetValue(key, out var weakRef) \u0026amp;\u0026amp; weakRef.IsAlive) { return weakRef.Target; } return null; } 正确实现IDisposable 对于实现IDisposable接口的对象，使用using语句或手动调用Dispose方法来释放资源。\n1 2 3 4 5 6 7 8 public void ProcessData() { using (var stream = new FileStream(\u0026#34;data.txt\u0026#34;, FileMode.Open)) { // Use the stream } // stream is automatically disposed here } 定期清理长时间存在的集合 对于长时间存在的集合或缓存，定期清理不再使用的对象。\n1 2 3 4 public static void ClearCache() { cache.Clear(); } 通过以上方法，可以有效减少或避免C#中的内存泄漏问题，从而提升应用程序的性能和稳定性。\n","date":"2024-09-27T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/memory_leak/","title":"C#内存泄漏"},{"content":"在 C# 中，Invoke() 是一个用于调用方法的方法，它能够在运行时动态地调用一个方法。Invoke方法主要用于以下几种场景：\n委托的Invoke 委托是C#中的一种类型，它表示引用方法的对象。你可以通过委托来调用（或“调用”）它所引用的方法。Invoke 方法用于显式地调用委托所引用的方法。\n1 2 3 4 5 6 7 8 9 10 11 delegate void MyDelegate(string message); class Program{ static void Main() { MyDelegate myDelegate = new MyDelegate(Hello); myDelegate.Invoke(\u0026#34;Hello, World!\u0026#34;); // 显式调用 myDelegate(\u0026#34;Hello, World!\u0026#34;); // 隐式调用，效果与上面的Invoke相同 } static void Hello(string message) { Console.WriteLine(message); } } 在上面的代码中，myDelegate.Invoke(\u0026quot;Hello, World!\u0026quot;) 和 myDelegate(\u0026quot;Hello, World!\u0026quot;) 是等效的。通常，我们更倾向于使用隐式调用（即直接使用委托名和方法参数），因为它更简洁。\n反射的Invoke 反射是.NET框架提供的一种功能，它允许程序在运行时检查或修改其类型、成员和属性的行为。使用反射，你可以动态地创建和调用类型、方法、属性等。在这种情况下，Invoke 通常用于调用通过反射获取的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Program { static void Main() { var type = typeof(Program); var method = type.GetMethod(\u0026#34;Hello\u0026#34;);//GetMethod只能获取Public方法 method.Invoke(null, new object[] { \u0026#34;Hello, Reflection!\u0026#34; }); } public static void Hello(string message) { Console.WriteLine(message); } } 在上面的代码中，我们使用反射来获取Program类中的Hello方法，并使用Invoke来调用它。注意，当使用反射调用静态方法时，第一个参数（即实例对象）通常为null。对于实例方法，你需要提供一个有效的实例对象作为第一个参数。\n跨线程控件Invoke(Windows Forms 和 WPF) 在 Windows Forms 或 WPF 应用程序中，当需要从非 UI 线程更新 UI 控件时，可以使用控件的 Invoke方法。这是因为 UI 控件只能在其所属的 UI 线程上进行操作。如果在其他线程上直接修改控件状态，可能会引发异常或导致不可预测的行为。\nControl.Invoke（Windows Forms） Dispatcher.Invoke（WPF） 同步方法，调用后会阻塞调用线程，直到在 UI 线程上执行完指定委托并返回结果。 异步委托调用 BeginInvoke (Windows Forms 和 WPF) Control.BeginInvoke（Windows Forms） Dispatcher.BeginInvoke（WPF） 异步方法，立即返回，不会阻塞调用线程。指定的委托将在 UI 线程上异步执行。 事件和回调 在某些情况下，Invoke可能被用作事件处理或回调机制的一部分。例如，在异步编程或多线程环境中，当某个事件发生时，可能需要通过Invoke来调用一个事件处理程序或回调函数。\n","date":"2024-09-26T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/c%23invoke/","title":"C# Invoke"},{"content":"C++ 编译过程 C++ 是一门高性能编程语言，它被广泛应用于世界最前沿的技术应用当中——从数据挖掘、大数据，到自动驾驶汽车、机器人，再到电子游戏和视频处理，C++ 的身影可谓无处不在。作为一名 C++ 程序员，你已经相当精通这门语言，对多线程和并行编程等主题也有了一定的了解。但你是否曾经揭开过编译器那神秘的面纱，是否好奇过在编译期间到底发生了什么事？\n这是一个非常值得讨论的问题，今天这篇文章里，我们将详细聊聊你最需要了解的几个重点细节。对编译器内部工作原理的了解能帮你更深刻地理解代码，避开许多常见的“坑”，从而进一步提高你的编程水平。\n编译流程 现在，让我们一起打开编译器的“小黑盒”，用最简明的办法来解释 C++ 编译器到底都对你的代码施了什么“魔法”吧。\n作为一门高级编程语言，C++ 让程序员的编程工作变得更加容易——低级机器语言一板一眼的本性难以用于编写足够复杂的现代应用程序。编译器通过将 C++ 源码转换成计算机可以执行的二进制文件，填补了高级 C++ 语言和机器语言之间的空白。\n总的来说，编译过程还比较复杂，一般可以分为三个阶段：\n预处理 Preprocessing 在实际编译工作开始之前，预处理器指令指示编译器对源码进行临时扩充，以为之后的步骤做好准备。\n在 C++ 中，预处理器指令以 # 号开头，比如 #include、#define 和 #if 等。在这一阶段，编译器逐个处理 C++ 源码文件。对于 #define 指令，编译器将源码中的宏替换成宏定义中的内容；对于 #if、#ifdef 和 #ifndef 指令，编译器将有选择地跳过或选中部分源代码；而对于 #include 指令，编译器将把对应的库的源码插入到当前源代码中——这通常是一些通用的声明。被 #include 指令引入的头文件（ .h ）往往会包含大量的代码，你引入的越多，最后生成的预编译文件就越大。总的来说，预编译过的文件会比原来的 C++ 源码更大一些。\n通过上面这些替换和插入操作，预处理器产生的是被合为一体的输出文件。预处理器还会在代码中插入记号，使编译器能分辨出每一行来自哪个文件，以便在调试过程中能生成对应的错误信息。在开发调试你的 C++ 程序时，这些错误信息能给你很多帮助。\n编译和汇编 Compilation \u0026amp; assembly 在这一阶段，编译器通过两个连续的步骤，将预处理器产生的代码编译成目标文件（object file）。\n首先，编译器将去除了预编处理器指令的纯 C++ 代码编译成底层汇编代码。在这一步中，编译器会对代码进行检查优化，指出语法错误、重载决议错误及其他各种编译错误。在 C++ 中，如果一个对象只声明，不进行定义，编译器仍然可以从源代码产生目标文件——因为这个对象也可以指向某些当前代码中还未定义的标识符。\n其次，汇编器将上一步生成的汇编代码逐行转换成字节码（也就是机器码）。实际上，如果你希望把代码的不同部分分开编译的话，编译过程在这一步之后就可以停止了。这一步生成的目标文件可以被放在被称为静态库的包中，以备后续使用——也就是说，如果你只修改了一个文件，你并不需要重新编译整个项目的源代码。\n链接 Linking 链接器利用编译器产生的目标文件，生成最终结果。\n在这一阶段，编译器将把上一阶段中编译器产生的各种目标文件链接起来，将未定义标识符的引用全部替换成它们对应的正确地址。没有把目标文件链接起来，就无法生成能够正常工作的程序——就像一页没有页码的目录一样，没什么用处。完成链接工作之后，链接器根据编译目的不同，把链接的结果生成为一个动态链接库，或是一个可执行文件。\n链接的过程也会抛出各种异常，通常是重复定义或者缺失定义等错误。不只是没进行定义的情况，如果你忘记将对某个库或是目标文件的引用导入进来，让链接器能找到定义的话，也会发生这类错误。重复定义则刚好相反，当有两个库或目标文件中含有对同一个标识符的定义时，就可能出现重复定义错误。\n理解编译过程有什么用？ 当你对编译过程的各个阶段有了新的理解，你就能更好地理解编译错误或连接错误产生的原因，并避免这些与编译相关的潜在问题。比如，如果你理解了预处理过程，你就能利用头文件保护符（用于保护头文件内容不被错误地多次包含的预编译器指令）防止一些编译错误的出现。\n对 C++ 编译细节的充分了解，能使你从一个完全不同的角度看待整个编程过程，也让你对原先以为是理所当然的编译过程有了新的认识。\n如何使用 C++ 编译器 构建并运行一个 C++ 程序所需的基本步骤有：\n使用一个编辑器或是编程环境（IDE），构建一个语法正确的 C++ 源文件。 运行编译器对源文件进行编译，生成可执行文件。 运行生成的文件。 编译器的特性差异很大，即使在同一个编译器的不同版本之间也是这样；同样，它们的选项也非常丰富，比如在代码生成、调试、浮点数行为、库处理等方面，都有着相当多的选项。\nC++ 编译器纵览 现在你已经对 C++ 的编译有了一定的了解，那么你该用哪种编译器呢？\n总体上说，你可以按编译器的许可类型（免费或是收费），使用方式（本地安装或是在线编译）以及所支持的操作系统（Windows、OS X 或 Linux）来分类。\n下面是几点建议：\n如果你在 Linux 上进行编程，**GNU 编译器套装（GCC）**是个非常流行的选项。它是免费的，而且你所用的 Linux 发行版的软件包仓库里通常就有。 对于 macOS 来说，Clang 是个默认选项，它随 Xcode 的命令行工具一起安装。使用 Clang 也是免费的。 Cygwin 项目为 Windows 系统提供了一系列 Linux 工具集，包括 GCC 在内。你可以使用 Cygwin 来运行 GCC 或 Clang，但请注意，用这种方式生成的代码需要 Cygwin 才能运行。 Windows 系统的另外一种选择是 MinGW，它不依赖于 Cygwin，而且能生成可原生在 Windows 上运行的可执行程序。 有些 IDE 本身在代码编辑器之外就已经包含了编译器。比如 macOS 上的 Xcode，以及 Windows 上的 Visual Studio 等。此外，还有许多专业化的编译器，比如英特尔 C++ 编译器等，为特定的需求专门定制了一些特性。比如，英特尔的编译器在自家的处理器上能更有效地利用多核心架构，产生的代码在英特尔的硬件上运行速度更快。这类专业化的编译器常常需要用户购买价格不菲的授权才能使用。\n如果你发现自己正在考虑使用某种不是很流行的编译器，请认真了解它的标准依从性。避免使用那些不符合 ISO 标准，或不提供可靠实现的标准库的编译器。这里提到的“标准库”是 C++ 自带的大量库文件；而“库文件”，则是已经“打包”好，可以在其他程序中重复使用的预编译代码的集合。\n有些编译器和库文件一起被嵌入在软件开发工具（IDE）提供的框架中。这些框架很有用，但如果你打算更换你的工具链，你可能很难脱离它们。\n在线 C++ 编译器 在线编译器是种很有用的工具，它能让你快速编译代码，而不需要在电脑上安装完整的编译工具链。这让程序员能更轻易的摆弄代码，熟悉最新的语言特性，或是在线分享代码片段，实时合作编辑，以及测试各种不同的编译器等。除了狭义的“编译”功能之外，大部分在线编译器还会执行编译完的程序，并将输出结果显示出来。\n和离线编译器一样，在线编译器支持的 C++ 标准版本和提供的特性也千差万别，从使用 flag 标识来定义编译参数，到处理标准输入并传入命令行和运行时参数等待，不一而足。\n常用的在线编译器有下面这几个：\nCompile Explorer Repl.it IDEone Codepad 你还可以在这里看到关于更多在线编译器的列表，已按特性进行分类。\n","date":"2024-09-25T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/cppcompile/","title":"Cpp编译"},{"content":"C++中基类的析构函数为什么要用virtual虚析构函数？\n大家知道，析构函数是为了在对象不被使用之后释放它的资源，虚函数是为了实现多态。那么把析构函数声明为vitual有什么作用呢？ 直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。\n请看下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: Base() {}; // Base的构造函数 ~Base() // Base的析构函数 { cout \u0026lt;\u0026lt; \u0026#34;Output from the destructor of class Base!\u0026#34; \u0026lt;\u0026lt; endl; }; // virtual ~Base() // Base的析构函数 // { // cout \u0026lt;\u0026lt; \u0026#34;Output from the destructor of class Base!\u0026#34; \u0026lt;\u0026lt; endl; // }; virtual void DoSomething() { cout \u0026lt;\u0026lt; \u0026#34;Do something in class Base!\u0026#34; \u0026lt;\u0026lt; endl; }; }; class Derived : public Base { public: Derived() {}; // Derived的构造函数 ~Derived() // Derived的析构函数 { cout \u0026lt;\u0026lt; \u0026#34;Output from the destructor of class Derived!\u0026#34; \u0026lt;\u0026lt; endl; }; void DoSomething() { cout \u0026lt;\u0026lt; \u0026#34;Do something in class Derived!\u0026#34; \u0026lt;\u0026lt; endl; }; }; int main() { Derived *pTest1 = new Derived(); // Derived类的指针 pTest1-\u0026gt;DoSomething(); delete pTest1; cout \u0026lt;\u0026lt; endl; Base *pTest2 = new Derived(); // Base类的指针 pTest2-\u0026gt;DoSomething(); delete pTest2; return 0; } 先看程序输出结果：\n1 2 3 4 5 6 Do something in class Derived! Output from the destructor of class Derived! Output from the destructor of class Base! Do something in class Derived! Output from the destructor of class Base! 可以正常释放pTest1的资源，而没有正常释放pTest2的资源，因为从结果看Derived类的析构函数并没有被调用。通常情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。原因是指针pTest2是Base类型的指针，释放pTest2时只进行Base类的析构函数。\n在代码~Base析构函数前面加上virtual关键字后的运行结果如下：\n1 2 3 4 5 6 7 Do something in class Derived! Output from the destructor of class Derived! Output from the destructor of class Base! Do something in class Derived! Output from the destructor of class Derived! Output from the destructor of class Base! 此时释放指针pTest2时，由于Base的析构函数是virtual的，就会先找到并执行Derived类的析构函数，然后再执行Base类的析构函数，资源正常释放，避免了内存泄漏。\n因此，只有当一个类被用来作为基类的时候，才会把析构函数写成虚函数。\n","date":"2024-09-25T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/why_virtual_destructor/","title":"虚析构函数"},{"content":"C#中out和ref之间的区别 首先：两者都是按地址传递的，使用后都将改变原来参数的数值。\n其次：ref可以把参数的数值传递进函数，但是out是要把参数清空，就是说你无法把一个数值从out传递进去的，out进去后，参数的数值为空，所以你必须初始化一次。这个就是两个的区别，或者说就像有的网友说的，ref是有进有出，out是只出不进。\nref（C# 参考） ref 关键字使参数按引用传递。其效果是，当控制权传递回调用方法时，在方法中对参数的任何更改都将反映在该变量中。若要使用 ref 参数，则方法定义和调用方法都必须显式使用 ref 关键字。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class RefExample { static void Method(ref int i) { i = 44; } static void Main() { int val = 0; Method(ref val); // val is now 44 } } 传递到 ref 参数的参数必须最先初始化。这与 out 不同，后者的参数在传递之前不需要显式初始化。\n尽管 ref 和 out 在运行时的处理方式不同，但在编译时的处理方式相同。因此，如果一个方法采用 ref 参数，而另一个方法采用 out 参数，则无法重载这两个方法。例如，从编译的角度来看，以下代码中的两个方法是完全相同的，因此将不会编译以下代码：\n1 2 3 4 5 6 7 class CS0663_Example { // Compiler error CS0663: \u0026#34;cannot define overloaded // methods that differ only on ref and out\u0026#34;. public void SampleMethod(ref int i) { } public void SampleMethod(out int i) { } } 但是，如果一个方法采用 ref 或 out 参数，而另一个方法不采用这两个参数，则可以进行重载，如下例所示：\n1 2 3 4 5 class RefOutOverloadExample { public void SampleMethod(int i) { } public void SampleMethod(ref int i) { } } out（C# 参考） out 关键字会导致参数通过引用来传递。这与 ref 关键字类似，不同之处在于 ref 要求变量必须在传递之前进行初始化。若要使用 out 参数，方法定义和调用方法都必须显式使用out 关键字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class OutExample { static void Method(out int i) { i = 44; } static void Main() { int value; Method(out value); // value is now 44 } } 尽管作为 out 参数传递的变量不必在传递之前进行初始化，但需要调用方法以便在方法返回之前赋值。\nref 和 out 关键字在运行时的处理方式不同，但在编译时的处理方式相同。因此，如果一个方法采用 ref 参数，而另一个方法采用 out 参数，则无法重载这两个方法。例如，从编译的角度来看，以下代码中的两个方法是完全相同的，因此将不会编译以下代码：\n1 2 3 4 5 6 7 class CS0663_Example { // Compiler error CS0663: \u0026#34;Cannot define overloaded // methods that differ only on ref and out\u0026#34;. public void SampleMethod(out int i) { } public void SampleMethod(ref int i) { } } 但是，如果一个方法采用 ref 或 out 参数，而另一个方法不采用这两类参数，则可以进行重载，如下所示：\n1 2 3 4 5 class RefOutOverloadExample { public void SampleMethod(int i) { } public void SampleMethod(out int i) { } } 下面是本人的一些心得：\n区别： ref和out的区别在C# 中，既可以通过值也可以通过引用传递参数。通过引用传递参数允许函数成员更改参数的值，并保持该更改。若要通过引用传递参数， 可使用ref或out关键字。ref和out这两个关键字都能够提供相似的功效，其作用也很像C中的指针变量。它们的区别是：\n1、使用ref型参数时，传入的参数必须先被初始化。对out而言，必须在方法中对其完成初始化。\n2、使用ref和out时，在方法的参数和执行方法时，都要加Ref或Out关键字。以满足匹配。\n3、out适合用在需要retrun多个返回值的地方，而ref则用在需要被调用的方法修改调用者的引用的时候。\nout\n方法参数上的 out 方法参数关键字使方法引用传递到方法的同一个变量。当控制传递回调用方法时，在方法中对参数所做的任何更改都将反映在该变量中。\n当希望方法返回多个值时，声明 out 方法非常有用。使用 out 参数的方法仍然可以返回一个值。一个方法可以有一个以上的 out 参数。\n若要使用 out 参数，必须将参数作为 out 参数显式传递到方法。out 参数的值不会传递到 out 参数。\n不必初始化作为 out 参数传递的变量。然而，必须在方法返回之前为 out 参数赋值。\n属性不是变量，不能作为 out 参数传递。\nref是 有进有出，而out是 只出不进。\n","date":"2024-09-19T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/ref_and_out/","title":"C#中out和ref之间的区别"},{"content":"不知道你在开发过程中有没有遇到过这样的困惑：这个变量怎么值被改？这个值怎么没变？\n今天就来和大家分享可能导致这个问题的根本原因值传递 vs 引用传递。\n在此之前我们先回顾两组基本概念：\n值类型 vs 引用类型\n值类型： 直接存储数据，数据存储在栈上；\n引用类型： 存储数据对象的引用，数据实际存储在堆上。\n形参 vs 实参\n形参： 即形式参数，表示调用方法时，方法需要你传递的值。方法声明定义了其形参。也就是说在定义方法时，紧跟在方法名后面括号中的参数列表就是形参。\n实参： 即实际参数，表示调用方法时，你传递给方法形参的值。调用代码在调用过程时提供实参。也就是说在调用方法时，紧跟在方法名后面括号中的参数列表就是实参。\n再来回顾一下值类型和引用类型在内存中是怎么存储的呢？\n对于值类型变量的值直接存储在栈中，如下图的int a=10，10就直接存在栈空间中，而其栈空间对应的内存地址为0x66666668；对于引用类型变量本身存储的是实例对象的引用，即实例对象在堆中的实际内存地址，因此引用类型变量是存储其实例对象的引用于栈上，如下图中变量Test a在栈中实际存储的是实例对象Test a在堆中的内存地址0x88888880，而栈空间对应的内存地址为0x66666668。\n栈也是有内存地址的，这一点很重要，无论栈空间上存储的是值还是引用地址，这个栈空间本身也有自己对应的内存地址。\n什么是值传递？什么是引用传递？\n值传递：如果变量按值传递给方法，则会把变量的副本传递给方法。对于值类型则把变量的副本传递给方法，对于引用类型则把变量的引用的副本传递给方法。因此被调用方法参数会创建一个新的内存地址用于接收存储变量，因此在方法内部对变量修改并不会影响原来的值。\n引用传递：如果变量按引用传递给方法，则会把变量的引用传递给方法，对于值类型则把变量的栈空间地址传递给方法，对于引用类型则把变量的引用的栈空间地址传递给方法。因此被调用方法参数不会创建一个新的内存地址用于接收存储变量，意味着形参与实参共同指向相同的内存地址，因此在方法内部修对变量修改会影响原来的值。\n上面的描述可能有点拗口，下面我们在基于值类型、引用类型、值传递、引用传递各种组合进行一个详细说明。\n01、值类型按值传递 当值类型按值传递时，调用者会把值类型变量的副本传递给方法，因此被调用方法参数会创建一个新的内存地址用于接收存储变量，因此当在方法内部对参数进行修改时并不会影响调用者调用处的值类型变量。\n传递值类型变量的副本就是相当于在栈上，又复制了一个同样的值，而且内存地址还不一样，所以互不影响。如下图把a赋值给b，则b直接新开辟了一个栈空间，虽然a和b都是10，但是它们在不同的地址空间中，因此如果他们各自被修改了，也互不影响。\n下面我们写个例子演示一下，这个例子就是定义个变量a并赋值，然后调用一个方法此方法内对传进来的参数a进行加1，具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static void ValueByValueRun() { var a = 10; Console.WriteLine($\u0026#34;调用者-调用方法前 a 值：{a}\u0026#34;); ChangeValueByValue(a); Console.WriteLine($\u0026#34;调用者-调用方法后 a 值：{a}\u0026#34;); } public static void ChangeValueByValue(int a) { Console.WriteLine($\u0026#34; 被调用方法-接收到 a 值：{a}\u0026#34;); a = a + 1; Console.WriteLine($\u0026#34; 被调用方法-修改后 a 值：{a}\u0026#34;); } 运行结果如下：\n通过代码执行结果可以发现，方法内对变量的修改已经生效，但是不没有影响到调用者调用处的变量值。\n02、引用类型按值传递 当引用类型按值传递时，调用者会把引用类型变量的引用副本传递给方法，因此被调用方法参数会创建一个新的内存地址用于接收存储变量，而对于一个引用类型变量来说其本身存储的就是引用类型实例对象的引用副本，而方法接收到的也是此变量引用的副本，所以调用者参数和被调用方法参数是引用了同一个实例对象的两个引用副本。如下图Test a可以理解为调用者传的实参，Test b可以理解为被调用方法定义的形参，这两个参数都只是指向堆中Test a的引用副本。\n因此可以得出两个结论：\n1、变量a和b都是指向实例对象Test a的引用，所以无论变量a或b，只要有一个更新了实例成员则另一个变量也会同步发生变化。\n2、虽然变量a和b都是指向实例对象Test a的引用，但是他们存储在栈上的内存地址却不同，因此如果他们各种重新分配实例也就是new一个新对象，则另一个变量无法感知到还是保持原因状态不变。\n我们先用代码说明第一个结论：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void ChangeReferenceByValueRun() { var a = new Test { Age = 10 }; Console.WriteLine($\u0026#34;调用者-调用方法前 a.Age 值：{a.Age}\u0026#34;); ChangeReferenceByValue(a); Console.WriteLine($\u0026#34;调用者-调用方法后 a.Age 值：{a.Age}\u0026#34;); } public static void ChangeReferenceByValue(Test a) { Console.WriteLine($\u0026#34; 被调用方法-接收到 a.Age 值：{a.Age}\u0026#34;); a.Age = a.Age + 1; Console.WriteLine($\u0026#34; 被调用方法-修改后 a.Age 值：{a.Age}\u0026#34;); } 运行结果如下：\n可以看到被调用方法中a实例对象的Age属性发生变化后，调用者中变量也同步发生了变化。\n对于第二个结论我们这样论证，在方法中直接对参数new一个新对象，看看原变量是否发生变化，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static void NewReferenceByValueRun() { var a = new Test { Age = 10 }; Console.WriteLine($\u0026#34;调用者-调用方法前 a.Age 值：{a.Age}\u0026#34;); NewReferenceByValue(a); Console.WriteLine($\u0026#34;调用者-调用方法后 a.Age 值：{a.Age}\u0026#34;); } public static void NewReferenceByValue(Test a) { Console.WriteLine($\u0026#34; 被调用方法-接收到 a.Age 值：{a.Age}\u0026#34;); a = new Test { Age = 100 }; Console.WriteLine($\u0026#34; 被调用方法-new后 a.Age 值：{a.Age}\u0026#34;); } 执行结果如下：\n可以发现当在方法中对变量执行new操作后，调用者处的变量并没有发生变化。\n为什么会这样呢？因为对于引用类型来说，形参和实参是对引用类型的实例对象引用的两个副本，而这两个副本存储在栈上又分别在不同的内存地址空间上，而new主要就是重新分配内存，这就导致形参变量a=new后，栈上形参变量a指向了Test新的实例对象的引用，而实参变量a还是保持原有实例对象引用不变。\n如下图所示。\n03、值类型按引用传递 当值类型按引用传递时，调用者会把值类型变量对应的栈空间地址传递给方法，因此被调用方法参数不会创建一个新的内存地址用于接收存储变量，因此当在方法内部对参数进行修改时并同样会影响调用者调用处的值类型变量。\n传递值类型变量对应的栈空间地址就意味着形参与实参共同指向相同的内存地址，所以才导致对形参修改时，实参也会同步发生变化。\n我们用一个小例子演示一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void ValueByReferenceRun() { Console.WriteLine($\u0026#34;值类型按引用传递\u0026#34;); var a = 10; Console.WriteLine($\u0026#34;调用者-调用方法前 a 值：{a}\u0026#34;); ChangeValueByReference(ref a); Console.WriteLine($\u0026#34;调用者-调用方法后 a 值：{a}\u0026#34;); } public static void ChangeValueByReference(ref int a) { Console.WriteLine($\u0026#34; 被调用方法-接收到 a 值：{a}\u0026#34;); a = a + 1; Console.WriteLine($\u0026#34; 被调用方法-修改后 a 值：{a}\u0026#34;); } 执行结果如下：\n可以发现调用者处的值类型变量已经发生改变。\n04、引用类型按引用传递 当引用类型按引用传递时，调用者会把引用类型变量对应的栈空间地址传递给方法，因此被调用方法参数不会创建一个新的内存地址用于接收存储变量，因此当在方法内部对参数进行修改时并同样会影响调用者调用处的引用类型变量。\n传递引用类型变量对应的栈空间地址就意味着形参与实参共同指向相同的内存地址，因此对形参修改时，实参也会同步发生变化，而且这个里的修改不单单指修改实例成员，还包括new一个新实例对象。\n下面我们看一个修改实例成员的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void ChangeReferenceByReferenceRun() { Console.WriteLine($\u0026#34;引用类型按引用传递 - 修改实例成员\u0026#34;); var a = new Test { Age = 10 }; Console.WriteLine($\u0026#34;调用者-调用方法前 a.Age 值：{a.Age}\u0026#34;); ChangeReferenceByReference(ref a); Console.WriteLine($\u0026#34;调用者-调用方法后 a.Age 值：{a.Age}\u0026#34;); } public static void ChangeReferenceByReference(ref Test a) { Console.WriteLine($\u0026#34; 被调用方法-接收到 a.Age 值：{a.Age}\u0026#34;); a.Age = a.Age + 1; Console.WriteLine($\u0026#34; 被调用方法-修改后 a.Age 值：{a.Age}\u0026#34;); } 执行结果如下：\n再看看new一个新对象的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void NewReferenceByReferenceRun() { Console.WriteLine($\u0026#34;引用类型按引用传递 - new 新实例\u0026#34;); var a = new Test { Age = 10 }; Console.WriteLine($\u0026#34;调用者-调用方法前 a.Age 值：{a.Age}\u0026#34;); NewReferenceByReference(ref a); Console.WriteLine($\u0026#34;调用者-调用方法后 a.Age 值：{a.Age}\u0026#34;); } public static void NewReferenceByReference(ref Test a) { Console.WriteLine($\u0026#34; 被调用方法-接收到 a.Age 值：{a.Age}\u0026#34;); a = new Test { Age = 100 }; Console.WriteLine($\u0026#34; 被调用方法-new后 a.Age 值：{a.Age}\u0026#34;); } 执行结果如下：\n另外string是一个特殊的引用类型，string类型变量的按值传递和按引用传递和值类型是一致的，也就是要把string类型当值类型一样看待就行。string类型的特殊性我们后面会单独具体介绍。\n在C#中以下修饰符可应用与参数声明，并且会使得参数按引用传递：ref、out、readonly ref、in。对于每个修饰符具体怎么使用就不再这里细说了。\n","date":"2024-09-19T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/value_and_reference/","title":"值传递 vs 引用传递"},{"content":" 1 2 3 4 5 \u0026lt;UserControl x:Class=\u0026#34;RentopolyNew.Rentals.ViewRentalsView\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; d:DataContext=\u0026#34;{d:DesignInstance Type=local:ViewRentalsViewModel,IsDesignTimeCreatable=False}\u0026#34;\u0026gt; \u0026lt;/UserControl\u0026gt; 分析 d:DataContext 的作用 d:DataContext 概述:\nd:DataContext 是在 XAML 中为设计时数据上下文（DataContext）设置的命名空间属性。 它只在设计时使用，不会影响运行时的行为。 DesignInstance:\nd:DesignInstance 是 XAML 中的一个扩展标记，用于指定设计时数据上下文的实例。 它可以帮助开发者在设计视图中看到绑定的数据结构，从而方便布局和设计。 属性解析:\n1 Type=local:ViewRentalsViewModel 指定设计时数据上下文的类型为 ViewRentalsViewModel。 local 通常是项目中命名空间的一个前缀。 ViewRentalsViewModel 是一个视图模型类，应该定义在 local 命名空间中。 1 IsDesignTimeCreatable=False 表示在设计时不创建这个视图模型的实例。 通常用于复杂的视图模型，可能需要特定的构造函数参数或初始化逻辑，无法在设计时轻松创建。 作用及好处 提高设计效率: 设计时数据上下文允许在设计器中显示数据模板、绑定和控件的外观，使开发者可以更好地调整布局和样式，而不需要运行应用程序。 防止设计时错误: 通过设置 IsDesignTimeCreatable=False，可以避免因为设计时无法创建视图模型实例而导致的设计器错误或崩溃。 示例上下文 假设你的项目中有一个 ViewRentalsViewModel 类，并且你希望在设计视图中预览 ViewRentalsView 的布局，那么可以这样设置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ViewRentalsViewModel.cs namespace RentopolyNew.Rentals { public class ViewRentalsViewModel { // ViewModel properties and methods } } \u0026lt;!-- ViewRentalsView.xaml --\u0026gt; \u0026lt;UserControl x:Class=\u0026#34;RentopolyNew.Rentals.ViewRentalsView\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:d=\u0026#34;http://schemas.microsoft.com/expression/blend/2008\u0026#34; xmlns:local=\u0026#34;clr-namespace:RentopolyNew.Rentals\u0026#34; d:DataContext=\u0026#34;{d:DesignInstance Type=local:ViewRentalsViewModel,IsDesignTimeCreatable=False}\u0026#34;\u0026gt; \u0026lt;!-- UserControl content here --\u0026gt; \u0026lt;/UserControl\u0026gt; 代码总结 d:DataContext 用于在设计时设置数据上下文，仅影响设计视图，不影响运行时行为。 DesignInstance 指定数据上下文的类型，并可以控制是否在设计时创建实例。 提高设计效率，防止设计时错误。 下一步建议 a. 考虑将 IsDesignTimeCreatable 设置为 True，如果 ViewRentalsViewModel 可以在设计时轻松创建，以便更好地预览设计视图。\nb. 添加更多的设计时数据，以便在设计器中预览更复杂的 UI 布局和绑定。\n","date":"2024-08-28T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/datacontentinxaml/","title":"DataContent in Xaml"},{"content":"Git Git 是一种分布式版本控制系统，用于管理软件项目的源代码。它是由 Linux 之父 Linus Torvalds 开发的，并已经成为了现代软件开发领域中最流行的版本控制系统之一。\n使用 Git 可以追踪代码的历史修改记录，方便团队协作、代码共享和代码重构。Git 的基本工作流程如下：\n在开始编写代码之前，首先需要创建一个 Git 仓库（repository），用于存储代码和版本历史记录。 在编写代码时，可以通过 git add 命令将更改的文件添加到 Git 的暂存区（staging area）中。 通过 git commit 命令将暂存区中的更改提交到 Git 仓库中，并生成一个新的版本号（commit hash）。 如果需要撤销某个提交，可以使用 git revert 命令来创建一个新的提交，该提交将会抵消先前的提交效果。 如果需要合并不同分支的代码，可以使用 git merge 命令进行合并。 如果需要查看代码的历史提交记录，可以使用 git log 命令来获取详细信息。 如果需要将代码推送到远程仓库，可以使用 git push 命令将本地代码推送到远程仓库。 如果需要从远程仓库中获取代码，可以使用 git pull 命令将远程代码拉取到本地。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 SVN与Git的的区别 SVN和Git都是版本控制系统，但它们有以下区别：\n分布式 vs 集中式：Git 是一种分布式版本控制系统，而 SVN 是一种集中式版本控制系统。在 Git 中，每个开发者都拥有本地代码库的完整副本，可以离线工作并在不同的工作流程之间自由转换。而在 SVN 中，所有开发者共享同一个中央代码库，并且需要有网络连接才能进行版本控制操作。 分支管理：Git 在分支管理方面比 SVN 更加强大和灵活。Git 的分支非常轻量级，创建和合并分支也很容易，因此可以轻松实现多人协作和并行开发。而在 SVN 中，分支比较重量级（即创建和合并分支需要花费相对更多的时间和资源），因此往往只用于重要的版本分支。 版本号：Git 使用 SHA-1 哈希值来标识每个提交，而 SVN 采用递增的数字版本号来标识每个提交。SHA-1 哈希值保证了每个提交的唯一性，而递增版本号则简化了版本控制过程。 整体性：由于 SVN 是一种集中式版本控制系统，因此所有数据都存储在中央代码库中。如果中央代码库损坏或丢失，可能会导致数据丢失或无法恢复。而 Git 是一种分布式版本控制系统，每个开发者都拥有完整的代码库副本，保证了代码的整体性和可靠性。 性能：Git 比 SVN 更快，特别是在处理大型仓库、分支合并以及比较代码差异时。Git 使用基于内容的哈希算法来检测文件是否修改，而 SVN 则需要检查文件的元数据（如时间戳和文件大小）来确定是否修改。 总之，虽然 SVN 和 Git 都是版本控制系统，但它们的设计和实现方式存在较大差异，开发人员应根据自身需求选择最适合的版本控制系统。\n常规操作 创建版本库 首先，打开终端或命令行界面，进入要创建版本库的目录下。\n接着，使用以下命令初始化一个空的 Git 仓库：\n1 git init 然后，将需要管理的文件添加到暂存区：\n1 git add \u0026lt;file\u0026gt; 你也可以使用以下命令一次性将所有变更添加到暂存区：\n1 git add . 接下来，提交暂存区中的变更到本地仓库，并添加一个描述信息：\n1 git commit -m \u0026#34;Initial commit\u0026#34; 现在，你已经成功地创建了一个版本库。你可以使用其他 Git 命令来管理它，例如：\ngit status：查看当前工作区和暂存区的状态。 git log：查看提交记录。 git branch：管理分支。 git remote：管理远程仓库。 版本回退 要将Git存储库版本回退，请使用git reset命令。如果您想要撤消上次提交并返回到上一个提交，则可以使用以下命令：\n1 git reset HEAD~1 这将使HEAD指向上一个提交，但不会删除您最新的更改。如果您希望完全返回到以前的提交并放弃所有更改，则可以添加\u0026ndash;hard选项：\n1 git reset --hard HEAD~1 请注意，此操作将永久删除您最新的更改，请谨慎使用。如果您已经将更改推送到远程存储库，则在执行此操作之前应先备份这些更改。\n理解工作区与暂存区的区别 Git有三个主要的工作区域：工作区（working directory）、暂存区（staging area）和版本库（repository）。\n工作区是指您电脑文件系统上用于修改文件的目录。在这里，您可以创建、编辑和删除文件。\n暂存区是一个中间状态，它充当了您提交更改的缓冲区。在Git中，您必须明确地将文件添加到暂存区，然后才能将其提交到版本库中。这样做的好处是，您可以对每个更改进行精细控制，并确保只提交需要保存的更改。\n版本库包含Git存储库的所有历史记录和元数据。它是Git存储库的核心组成部分，是由Git自动维护的。\n简而言之，工作区是您正在处理的实际文件，而暂存区是下一次提交所需更改的文件列表。它们之间的区别在于，您可以对工作区中的任何文件进行修改，但只有将它们添加到暂存区并将其提交到版本库中，它们才会成为Git跟踪的部分。\nGit撤销修改和删除文件操作 要撤销对文件的修改，可以使用git checkout命令：\n1 git checkout -- \u0026lt;filename\u0026gt; 此命令将覆盖工作树中指定文件的更改，还原为最近提交或上次检出的状态。\n要删除文件并将此更改提交到Git存储库中，可以使用git rm命令：\n1 2 git rm \u0026lt;filename\u0026gt; git commit -m \u0026#34;Remove file\u0026#34; 这将从工作树和版本历史记录中删除指定的文件。如果只是想从Git版本库中删除文件但保留在工作树中，则可以使用git rm命令的\u0026ndash;cached选项：\n1 2 git rm --cached \u0026lt;filename\u0026gt; git commit -m \u0026#34;Remove file from repository\u0026#34; 这将从版本历史记录中删除指定的文件，但保留在工作树中。\n远程仓库 如何添加远程仓库 要将本地代码库连接到远程仓库，可以使用以下git命令：\n首先，将本地代码库初始化为Git仓库（如果尚未完成）：\ngit init 添加远程仓库的URL，其中\u0026lt;remote-name\u0026gt;是自定义名称，\u0026lt;remote-url\u0026gt;是远程仓库的URL：\ngit remote add \u0026lt;remote-name\u0026gt; \u0026lt;remote-url\u0026gt; 可以使用以下命令确认远程仓库是否已成功添加：\ngit remote -v 此后，您就可以使用git push命令将代码推送到远程仓库，或使用git pull命令从远程仓库拉取代码。\n如何从远程库克隆 要从远程仓库克隆代码到本地，可以使用以下git命令：\n1 git clone \u0026lt;remote-url\u0026gt; 其中\u0026lt;remote-url\u0026gt;是远程仓库的URL。执行此命令后，Git将在当前目录下创建一个新目录，其中包含克隆的代码库副本。如果想指定不同的目录名，可以将目录名作为可选参数添加到命令中：\n1 git clone \u0026lt;remote-url\u0026gt; \u0026lt;directory-name\u0026gt; 在执行git clone命令时，还可以通过添加其他标志来更改默认行为，例如指定要克隆的分支、禁用克隆时自动检查的文件等。有关详细信息，请参阅相应的文档。\n创建与合并分支 创建一个新的分支可以使用以下命令：\n1 git branch \u0026lt;branch_name\u0026gt; 这将在当前所在的提交上创建一个名为 \u0026lt;branch_name\u0026gt; 的新分支。\n要切换到新创建的分支，可以使用以下命令：\n1 git checkout \u0026lt;branch_name\u0026gt; 创建并立即切换到该分支，可以使用以下命令：\n1 git checkout -b \u0026lt;branch_name\u0026gt; 合并分支可以使用以下命令：\n1 git merge \u0026lt;branch_name\u0026gt; 这将将 \u0026lt;branch_name\u0026gt; 分支中的更改合并到当前分支。\n处理冲突 当两个分支上的代码修改了同一部分，并且尝试将这两个分支合并时，就会发生代码冲突。Git提供了以下步骤来解决冲突：\n运行 git status 命令查看哪些文件包含冲突。 编辑有冲突的文件，手动解决文件中的冲突。 对编辑后的文件进行 git add，标记为已解决冲突的文件。 使用 git commit 提交更改，Git 会自动生成一个合并提交，其中包含各自分支中的更改。 注意：在解决冲突前，最好先备份当前的代码状态，以免不小心破坏代码库。另外，在处理冲突之前，可以通过运行 git diff 命令来查看冲突的源代码，以便更好地理解要解决的问题。\n分支管理策略 在 Git 中，常见的分支管理策略包括以下几个方面：\n主分支：主分支通常是最稳定的分支，用于发布生产版本。在 Git 中，主分支通常是 master 分支或者 main 分支。 开发分支：开发分支通常从主分支派生而来，在其上进行新功能或修复错误的开发。在 Git 中，通常使用 develop 分支作为开发分支。 特性分支：特性分支是为了开发单独的功能而创建的分支。这些分支通常从开发分支派生而来，并在实现目标后被合并回开发分支。在 Git 中，通常使用 feature/ 分支命名约定来表示特性分支。 发布分支：发布分支是用于准备发布版本的分支，通常从主分支派生而来。这些分支应该包含与发布相关的所有更改，并且应该经过全面测试和审核后再合并回主分支。在 Git 中，通常使用 release/ 分支命名约定来表示发布分支。 热修复分支：热修复分支通常用于快速修复紧急问题，例如安全漏洞或崩溃。这些分支通常从主分支派生而来，并且只包含必要的更改。在 Git 中，通常使用 hotfix/ 分支命名约定来表示热修复分支。 通过采用合适的 Git 分支管理策略，可以帮助团队更好地组织和管理代码，提高团队的协作能力和生产效率。除了上述常见的分支管理策略，还可以根据团队的具体需求和工作流程定制适合自己的分支管理策略。\nbug分支 在 Git 中，通常使用 bug 分支用于修复代码中的错误或缺陷。当发现 bug 时，可以从当前开发分支（如 develop 分支）创建一个 bug 分支，在该分支上进行错误修复。修复完成后，可以将更改提交到 bug 分支，并将其合并回开发分支和主分支。\n以下是一个典型的使用 Git bug 分支的流程：\n从当前开发分支（如 develop 分支）创建一个新的 bug 分支： 1 git checkout -b bug/fix-xxx 在 bug 分支上进行错误修复，包括必要的测试和代码审查。 提交更改并推送到远程仓库： 1 2 3 git add . git commit -m \u0026#34;Fix xxx bug\u0026#34; git push origin bug/fix-xxx 将 bug 分支合并回开发分支（如 develop 分支）： 1 2 git checkout develop git merge --no-ff bug/fix-xxx 测试修复是否正确，如果一切正常，则将开发分支合并回主分支（如 master 分支）： 1 2 git checkout master git merge --no-ff develop 通过使用 Git bug 分支，可以帮助团队更好地管理和修复代码中的错误和缺陷，同时保持代码库的稳定性和可靠性。\n多人协作 Git 是一个优秀的多人协作工具，以下是 Git 多人协作的一些最佳实践：\n使用分支：使用分支可以帮助团队成员在不影响主分支的情况下进行开发和测试，避免代码冲突和错误。建议采用主分支、开发分支、特性分支、发布分支、热修复分支等分支管理策略。 提交规范：每次提交代码时应该附加有意义的提交信息，描述本次提交的更改内容和目的。建议采用语义化版本号和提交信息模板等规范，以便更好地记录和追踪代码变更历史。 定期合并：团队成员应该定期将自己的分支合并回主分支或者开发分支。这可以避免较大的代码冲突和错误，并且保持代码库的整洁和可维护性。 代码审查：通过代码审查可以确保代码的质量和一致性，并且可以识别和纠正潜在的问题和错误。建议采用 pull request 和 code review 等工具和流程，以便团队成员对彼此的代码进行审查和反馈。 团队协作：团队成员之间应该保持及时和有效的沟通，共享技术和经验，并尽可能避免个人行为和偏见对项目和团队产生不良影响。 通过采用上述最佳实践，可以帮助团队高效协作、保证代码质量和稳定性，并提高团队的生产力和创造力。\n推送分支 在 Git 中，推送分支指将本地的分支提交到远程仓库中，使得其他团队成员可以访问和获取该分支的代码。以下是在 Git 中推送分支的一些常用命令：\n推送当前分支到远程仓库，并与远程分支关联： 1 git push -u origin \u0026lt;branch-name\u0026gt; 推送当前分支到远程仓库，并与远程分支合并： 1 git push origin \u0026lt;branch-name\u0026gt; 强制推送当前分支到远程仓库： 1 git push -f origin \u0026lt;branch-name\u0026gt; 删除远程分支： 1 2 3 git push origin :\u0026lt;branch-name\u0026gt; 或 git push --delete origin \u0026lt;branch-name\u0026gt; 在推送分支时，通常会遇到冲突等问题。如果发生冲突，需要先解决冲突，然后再进行推送。\n另外，在多人协作项目中，建议采用 pull request 和 code review 等工具和流程来对分支进行审查和反馈，以确保代码质量和稳定性。同时，也应该避免直接向主分支（如 master 分支）提交代码，而是应该使用分支管理策略来组织和管理代码。\n抓取分支 在 Git 中，抓取分支指从远程仓库拉取最新的代码和分支信息，并在本地创建相应的分支。以下是在 Git 中抓取分支的一些常用命令：\n拉取所有远程分支并更新本地分支： 1 git fetch --all 拉取一个特定的远程分支到本地： 1 git fetch origin \u0026lt;branch-name\u0026gt; 在本地创建基于远程分支的新分支： 1 git checkout -b \u0026lt;new-branch-name\u0026gt; origin/\u0026lt;remote-branch-name\u0026gt; 拉取远程分支并自动与本地分支关联： 1 2 3 git checkout --track origin/\u0026lt;remote-branch-name\u0026gt; 或 git checkout -t origin/\u0026lt;remote-branch-name\u0026gt; 抓取分支时，需要注意避免覆盖当前分支中未提交的更改。如果本地分支和远程分支存在冲突，需要解决冲突后才能将更改合并到本地分支中。\n通过抓取分支可以使得开发者获取最新的代码和分支信息，在本地进行代码修改和测试，并将更改推送回远程仓库以进行协作开发。\ngit可视化工具 Git 可视化工具可以帮助开发者更直观地查看和管理代码版本控制历史，以下是几个常用的 Git 可视化工具：\nGitKraken：GitKraken 是一款简单易用的 Git 可视化工具，支持 Windows、Mac 和 Linux 等多个平台。它提供了强大的图形界面，包括代码历史记录、分支管理、合并冲突解决等功能。 Sourcetree：Sourcetree 是由 Atlassian 公司开发的一款免费 Git 可视化工具，支持 Windows 和 Mac 平台。它提供了友好的用户界面，可以轻松地进行代码提交、分支管理和冲突解决等操作。 GitHub Desktop：GitHub Desktop 是 GitHub 公司出品的一款免费 Git 可视化工具，支持 Windows 和 Mac 平台。它提供了清晰明了的界面，可视化显示代码历史记录、分支管理、拉取请求（pull request）等功能，以及与 GitHub 网站的集成支持。 Git GUI：Git GUI 是 Git 官方提供的一个图形化界面的工具，支持 Windows、Mac 和 Linux 等多个平台。它虽然不如前面提到的工具那样友好易用，但是对于习惯命令行操作的开发者来说，Git GUI 可以提供便捷的图形化界面。 使用 Git 可视化工具可以帮助开发者更直观地理解和管理 Git 中的代码版本控制历史，提高协作效率和代码质量。\ngit add.和git add -a的区别 git add . 会把当前目录及子孙目录里的变动都加到暂存区 git add --all 或者git add -A会将项目里所有文件的变动都加到暂存区，也就是说该命令不论在项目的哪级目录执行，都有同样的效果。 ","date":"2024-08-20T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/git-skill/","title":"Git Skill"},{"content":"进入MySQL安装目录 \\bin 下 在目录输入”cmd“然后回车\n第二步 开启远程访问权限 在步骤一执行成功后的mysql\u0026gt;下，依次输入命令 use mysql、update user set host = \u0026lsquo;%\u0026rsquo; where user = \u0026lsquo;root\u0026rsquo;;、flush privileges; （分号别漏了）\n1 use mysql 1 update user set host = \u0026#39;%\u0026#39; where user = \u0026#39;root\u0026#39;; 1 flush privileges; ","date":"2024-08-20T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/mysqlorigin/","title":"Windows开启远程访问MySQL"},{"content":"前言 本文尽量使用图形工具介绍如何向开源项目提交 Pull Request，一次亲身经历提交 PR\nfork 项目 image\n克隆本地 image\n1 git clone https://github.com/liangtongzhuo/taro-ui.git 根据文档创建分支 拖进 SourceTree，基于 dev 创建分支\nimage\n提交的自己仓库 1 git add . \u0026amp;\u0026amp; git commit -m\u0026#34;fix(dos):修正文字 \u0026#34; \u0026amp;\u0026amp; git push 提交 Pull Request 第四步提交成功后，进入原来的仓库，点击 compare\nimage\n提交你的说明，选择合并的分支即可，剩下等待合并。\nimage\n结尾 开源的魅力就在于协同工作，提高效率。\n","date":"2024-08-20T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/git-pr/","title":"如何提交PR（Pull Request）"},{"content":"如果你对相机只有很少了解，那么看这篇文章再好不过啦，我结合很多资料，力图用最通俗易懂的方式进行讲解。\n相机拍摄时最重要的3个参数就是——光圈、快门、ISO\n次重要的参数有——焦距、景深、曝光\n在介绍光圈、快门、ISO之前，必须先介绍曝光。\n曝光准确的照片：\n过曝的照片：\n欠曝的照片：\n我们把一张完美曝光的照片理解成一桶刚刚装满的水，不多也不少，并且水里面是有杂质的，那么如何把这桶水装满呢？（先不考虑装到里面的水干不干净）\n（看见没有，我往水里面加了一下杂色，代表杂质）\n光圈：控制水龙头水量大小的开关\n快门：开了多久的水龙头\nISO：滤网\n如果你要把一个水桶装满水，需要打开水龙头然后等水装满就行了，那么你水龙头开的越大（光圈越大）哗哗哗的流水，流水的时间（快门速度）也就越短；同理，龙头开的越小（光圈越小）嘀嗒嘀嗒的流水，需要的时间（快门速度）就越长，这差不多就是快门和光圈之间的关系。\nISO在里面起到了一个滤网的作用，ISO（感光度）越高相当于滤网的空隙越大，那么出水量一定就大了，同理里面的杂质就会很多，所以拍出来的照片有很多的噪点和颗粒，如果ISO（感光度）低呢，那么就是说明滤网的间隙越小，越能过滤出杂质，所以水流的速度就满了，同时水里的杂质也就少了，拍出来的照片相对干净了很多（桶里面的水干净了很多）。\n从上面我们知道，曝光量由光圈、快门、ISO三者共同决定。\n光圈由F值表示，例如F1.4，F1.8，F3.5，F5.6，F16，数字越小代表光圈越大，例如F1.8\u0026gt;F5.6，光圈越大，代表水龙头开得越大，单位时间内流出的水也就越多（单位时间内进来的光也就越多）。\n如图所示，光圈越大，代表光孔越大，单位时间内进来的光肯定也就越多。例如某手机的光圈就是F1.8，很大，当然与相机不同的是，手机的光圈通常都是不可以改变的，也就是在任何情况这个手机的光圈都是F1.8。\n快门：开了多久的水龙头。\n具体到相机上，就是放了多长时间的光进来。在光圈和ISO一定的情况下，如果你只放了0.001秒的光进来，很明显这个总光量很少，如果你放了10秒钟的光进来，那么这个光的总量就很大。\n快门其实是相当于一个窗帘的东西，如果快门是30秒，说明窗帘打开了30秒后才拉上。\n快门通常用时间单位**秒（S）**表示，并且通常用分数表示，例如：\n1/4000 S，1/2000 S ，1/200 S， 1/60 S，1/5 S，1 S，15 S ，30S\n数字越小，代表快门越快，例如1/4000秒是非常快的快门。\n30秒的快门相当于把水龙头开了30秒，1/2000秒的快门相当于只放了两千分之一秒的水，那放出来的水肯定少得可怜，也就是放进来的光非常少。\nISO的高低：滤网的大小。\nISO越高，滤网的滤孔越大，进来的杂质就越多，当然同时出来的水（进来的光）也就越多。画面的噪点也就越多，画质越差。\nISO 的常见值是100， 200， 400， 800， 1600， 3200， 6400， 12800等等。\n从上面我们知道了，光圈、快门、ISO就是三个控制曝光量的因素，三个共同作用。它们就像杂技师手中的三个球，任何一个没耍好，曝光就会出问题。\n但是，这三个参数之间却并不能力往一处使，你需要在三者之间互相取舍，做出最优决策。\n很明显如果需要进的光足够多，思路有：光圈足够大、快门足够慢、ISO足够高。\n三者之中，除了大光圈没有明显缺点外（工业领域中大光圈也有缺点，即景深太浅），慢的快门和高的ISO都有明显的缺点。\n快门太慢：拍的照片容易模糊，例如快门是0.5秒，就像这样。\n这是因为，被拍的人是动的，你的手也是抖的，在0.5秒的时间里面已经足够它俩抖来抖去了。相机记录的是这0.5秒内所有的光线信息，而并不是0.5秒的最后末尾的那一瞬间的光线信息。\n如果你的快门足够快，例如1/500秒，那么，你的手抖动和被拍者的抖动在这么短的时间内可以认为基本没有移动多少，因此拍出来的照片是清晰的，就像这样：\n至于高ISO产生高噪点的缺点在上文已经提及。\n如果我们想要一张尽可能清晰、画质高、噪点少、曝光合适的照片，应该怎么办呢？\n必须要高速快门、低ISO，但是如果快门太快，ISO太低，那么曝光量就会不足，怎么办呢？只有用大光圈！！\n如果光圈开到最大也不行呢？那么这样还能实现清晰、画质高、噪点少、曝光合适的效果吗？不能！\n所以我们需要取舍，要么把快门变慢一点，要么把ISO调高一点，当然这些都是以降低照片质量为代价的。\n知道为什么大光圈镜头这么贵了吧？\n三脚架存在的意义：\n我们在上文说过，当光圈开到最大但曝光还不够的话，我们就需要取舍，要么把快门变慢一点增加曝光时间，要么把ISO调高一点增加感光度，当然这些在手持相机拍摄的时候都会降低照片质量。\n事实上，增加ISO（感光度）一定会降低画质，但是把快门变慢却未必，我们说将快门变慢主要是可能会使照片模糊，因为被摄者和人的手都是都是移动（抖动）的。\n那么如果把相机放在三脚架上，而且被拍的物体是不动的呢？那么这时候就不会产生抖动了。这就是三脚架存在的意义。\n事实上，就算你拍人或者动物的话，把相机放在三脚架上也会比手持画质要好，因为它至少避免了你手的抖动。\n当相机放在三脚架上拍静物的时候，无论快门速度为多少，都不会模糊，哪怕是曝光几个小时。\n焦距：\n为了简单起见，我们选择一个简单的定义：焦距就是透镜中心到焦点的距离。为了形象便于理解一点，你可以这样理解，焦距越长通常镜头也就越长。\n通常说焦距，我们会涉及两个概念：广角和长焦。\n广角一般是等效焦距在35mm及以下的焦距，等效焦距小于等于24mm的就是超广角；\n而长焦一般指85mm以上的焦距，如果在300mm以上则称为超长焦。\n广角的视野广；\n长焦的视野窄，但是可以拉近物体。\n下图是焦距和视角（视野宽还是窄）的对应关系图：\n例如广角镜头可以拍这样的照片：（宽广辽阔的壮观）\n长焦镜头可以拍这样的照片：（适合局部特写，百米之外如在眼前，长焦视觉上可以压缩空间）\n我必须说的是，好的广角镜头和长焦镜头都很贵。\n其实我主要是谈光圈、快门、ISO这个三个参数，为什么这里又要谈到焦距这个参数呢？这是因为我即将谈到的一个名词，叫做“安全快门”，而安全快门和等效焦距密切相关。\n数码相机的快门时间如果低于某个值 ，便很容易因为手的晃动，而让画面变得很模糊。这个快门值就是我们说的安全快门。安全快门一般是等效焦距的倒数。\n有一句很重要的话：等效焦距越长，抖动产生的影响就会越大，影像就会越模糊。\n原因分析如下：\n以某等效焦距为25mm — 750mm的普通数码相机为例：\n当你使用25mm焦距的时候，手持拍摄时快门应不慢于1/25秒，当使用750mm的焦距时，手持拍摄时的快门应不低于1/750秒。当然，如果用三脚架的话，就没有快门的限制了。\n但是，一旦你为了消除抖动的影响而使用了高速快门，这时就算你使用最大的光圈，曝光量可能还是不足，这时相机只有强行使用极高的ISO，例如ISO 3200或者ISO 6400，这时画质就会变得非常糟糕。\n解决这个矛盾的方法通常有两个：一个是使用三脚架杜绝抖动，另一个是使用防抖镜头以使用较慢的快门就可以有效减轻抖动的影响。\n但是……\n防抖镜头是很贵的。\n看这两个镜头，基本区别就是一个防抖一个不防抖，结果防抖的贵了近4000块钱。\n最后要谈的一个名词叫做“景深”。\n景深：在聚焦完成后，在焦点前后的范围内都能形成清晰的像，这一前一后的距离范围，便叫做景深。\n景深通常和“虚化”这个词联系在一起，景深浅即虚化强，景深深即虚化弱。\n浅景深的照片：（蜜蜂和花朵主体清晰，后面的绿叶几乎完全虚掉了）\n深景深的照片：（无论是主体石狮子还是后面的太和殿都很清晰）\n那么要获得浅的景深一般需要满足什么条件呢？\n1、大光圈；\n2、实际焦距较长；\n3、镜头离被摄者近，而背景离被摄者远。\n注：为了避免过于复杂，对于上文中的“等效焦距”和“实际焦距”的区别在此我不详述了。\n再补充一张经典的图吧：光圈、快门、ISO、景深\n","date":"2024-08-19T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/photography1/","title":"相机拍摄时最重要的三个参数——光圈、快门、ISO"},{"content":" 1 2 3 route print ​route delete ​route add 172.0.0.0 mask 255.0.0.0 172.17.140.1 -p ","date":"2024-08-13T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/routesetter/","title":"电脑内外网路由配置"},{"content":"在C#中，静态构造函数（也称为类型构造函数）是一种特殊的构造函数，用于初始化静态成员或执行只需要一次的操作。静态构造函数的主要特点包括：\n无需显式调用：静态构造函数在第一次访问类型的静态成员或实例成员之前，由运行时自动调用。\n不能有访问修饰符：静态构造函数不能有public、private等访问修饰符。它只能由类型定义来确定。\n无参数：静态构造函数不能有参数。\n每个类型只能有一个静态构造函数。\n不能通过对象实例来调用：静态构造函数只能通过类型本身触发，而不能通过类型的实例来触发。\n下面是一个简单的示例，展示了如何使用静态构造函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 using System; class MyClass { // 静态字段 public static int StaticField; // 静态构造函数 static MyClass() { Console.WriteLine(\u0026#34;静态构造函数被调用\u0026#34;); StaticField = 42; } // 实例构造函数 public MyClass() { Console.WriteLine(\u0026#34;实例构造函数被调用\u0026#34;); } // 静态方法 public static void StaticMethod() { Console.WriteLine(\u0026#34;静态方法被调用\u0026#34;); } } class Program { static void Main() { // 访问静态字段，触发静态构造函数 Console.WriteLine(MyClass.StaticField); // 创建实例，静态构造函数不会再次被调用 MyClass myClass = new MyClass(); // 调用静态方法 MyClass.StaticMethod(); } } 输出：\n1 2 3 4 静态构造函数被调用 42 实例构造函数被调用 静态方法被调用 在这个示例中，MyClass类定义了一个静态字段StaticField和一个静态构造函数。在Main方法中，第一次访问StaticField时，静态构造函数被调用并初始化了StaticField。随后的实例创建和静态方法调用不会再次触发静态构造函数。\n静态构造函数通常用于执行类型级别的初始化任务，例如设置静态字段的默认值、配置类型级别的资源等。它保证这些初始化逻辑在类型首次使用时恰当地执行。\n","date":"2024-08-12T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/static-ctor/","title":"静态构造函数"},{"content":"安装 EF.Sqlsever（sqlserver数据库提供程序） EF Tools\u0026ndash;\u0026gt;EF Design(安装到启动项) 跟踪查询 默认情况下，跟踪返回实体类型的查询。 跟踪查询意味着对实体实例所做的任何更改都由 SaveChanges持久化。 在以下示例中，检测到对博客分级的更改，并在 期间 SaveChanges保存到数据库中： Blogs上一定要指定主键\n1 2 3 var blog = context.Blogs.SingleOrDefault(b =\u0026gt; b.BlogId == 1); blog.Rating = 5; context.SaveChanges(); 在跟踪查询中返回结果时，EF Core 会检查实体是否已在上下文中。 如果 EF Core 找到现有实体，则返回相同的实例，这可能使用更少的内存，并且比无跟踪查询更快。 EF Core 不会使用数据库值覆盖条目中实体属性的当前值和原始值。 如果在上下文中找不到实体，EF Core 会创建一个新的实体实例并将其附加到上下文。 查询结果不会包含任何已添加到上下文但尚未保存到数据库中的实体。\n非跟踪查询 在只读方案中使用结果时，非跟踪查询十分有用。 通常可以更快速地执行非跟踪查询，因为无需设置更改跟踪信息。 如果不需要更新从数据库检索到的实体，则应使用无跟踪查询。 单个查询可以设置为不跟踪。 无跟踪查询还会根据数据库中的内容提供结果，而不考虑任何本地更改或添加的实体。\n1 2 3 var blogs = context.Blogs .AsNoTracking() .ToList(); 字段部分更新 1 2 3 4 5 var thiscarcom = await db.CarCommons.AsNoTracking() .FirstOrDefaultAsync(f =\u0026gt; f.CarName == thiscarbase.CarName); db.CarCommons.Attach(thiscarcom); db.Entry(thiscarcom).Property(p =\u0026gt; p.TaskStatus).IsModified = true; db.SaveChanges(); 1 2 3 4 5 6 7 8 9 db.Attach(item); db.Entry(item).State = EntityState.Modified;//将所有字段设置为要更新状态 db.Entry(item).Property(p =\u0026gt; p.TaskStatus).IsModified = false db.Entry(item).Property(p =\u0026gt; p.RobotStatus).IsModified = false; db.Entry(item).Property(p =\u0026gt; p.ArmStatus).IsModified = false; db.Entry(item).Property(p =\u0026gt; p.CurrentTraName).IsModified = false; db.Entry(item).Property(p =\u0026gt; p.CanLedTask).IsModified = false; db.Entry(item).Property(p =\u0026gt; p.Current_map).IsModified = false; db.SaveChanges();\t","date":"2024-08-09T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/efcore/","title":"EFcore"},{"content":" 在学习EF Core的时候使用Update-Database时候报错显示证书链是由不受信任的颁发机构颁发的：\n1 A connection was successfully established with the server, but then an error occurred during the login process. (provider: SSL Provider, error: 0 - 证书链是由不受信任的颁发机构颁发的。) 解决方法：\n直接在数据库连接字符串最后面”增加证书信任的配置。\nprotected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseSqlServer(\u0026quot;server=***;Database=***; user=***; Password=***;MultipleActiveResultSets = True;TrustServerCertificate=true\u0026quot;); base.OnConfiguring(optionsBuilder); } 最终成功执行：\n1 2 3 4 PM\u0026gt; Update-database Build started... Build succeeded. Done. ","date":"2024-08-07T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/efcore-notice/","title":"Efcore Update-Database显示证书链是由不受信任"},{"content":"使用实例池 EFCore2.0 为DbContext引入新的注册方式：透明地注册了 DbContext实例池，使用这种方式可以避免始终创建新的实例，EF Core 将重置其状态并将其存储在内部池中；当下次请求新的实例时，将返回该共用实例，而不是设置新的实例\n使用示例：\n1 services.AddDbContext\u0026lt;HandshakesWebDBContext\u0026gt;(options =\u0026gt; options.UseSqlServer(connectionConfiguration.WebDBConnection)); 替换为：\n1 2 builder.Services.AddDbContextPool\u0026lt;HandshakesWebDBContext\u0026gt;(options =\u0026gt; options.UseSqlServer(connectionConfiguration.WebDBConnection), poolSize: 80); //注意设置最大连接数，一旦超过默认配置的连接池最大数量，会回退到按需创建实例的行为 基准测试(官方) 测试代码：\n方法 数量 平均值 错误 标准偏差 Gen 0 Gen 1 Gen 2 已分配 WithoutContextPooling 1 701.6 us 26.62 us 78.48 us 11.7188 - - 50.38 KB WithContextPooling 1 350.1 us 6.80 us 14.64 us 0.9766 - - 4.63 KB 注意事项：虽然在大部分情况下这种做法对性能的提升可能并不是非常明显，但是这是一种好的实践方式，避免资源浪费的同时对性能带来一定的提升。\n使用拆分查询 了解什么是 笛尔卡乘积 ?\n通俗地来讲指的是从两个集合(Set)中的元素组成新的配对集合 以麦当劳套餐来比喻,门店将汉堡线和饮品线上的每个产品集合组成一个新的套餐会有多少种套餐\n在数据库中的表现形式正是联表查(join)操作 两个表在数据量不是很大的情况下查询来讲可能对性能影响模棱两可 但是对于一些因业务需求日益增加列的大宽表以及数据存量过大的表来讲就会产生查询过慢以及数据冗余的问题\n尤其适合一对多且子表数据量较大的场景。\n看一段Linq代码：\n1 2 3 4 5 6 7 8 var data = ctx.As .Include(x =\u0026gt; x.Bs) .Include(x =\u0026gt; x.Cs) .ThenInclude(x =\u0026gt; x.D1s) .Include(x =\u0026gt; x.Cs) .ThenIncude(x =\u0026gt; x.C1s) .ThenInclude(x=\u0026gt;x.D2s) .ToList(); 监控查看生成的Sql语句：\n1 2 3 4 5 6 7 8 9 10 11 12 SELECT [A].[Id], [A].[Name], [B].[Id], [B].[AId], [B].[Name], [C].[Id], [C].[AId], [C].[Name], [D1].[Id], [D1].[CId], [D1].[Name], [C1].[Id], [C1].[CId], [C1].[Name], [D2].[Id], [D2].[C1Id], [D2].[Name] FROM [As] AS [A] LEFT JOIN [Bs] AS [B] ON [A].[Id] = [B].[AId] LEFT JOIN [Cs] AS [C] ON [A].[Id] = [C].[AId] LEFT JOIN [D1s] AS [D1] ON [C].[Id] = [D1].[CId] LEFT JOIN [C1s] AS [C1] ON [C].[Id] = [C1].[CId] LEFT JOIN [D2s] AS [D2] ON [C1].[Id] = [D2].[C1Id] 毫无疑问，这一段糟糕的sql语句，假设每张表的数据量都很大的情况下，这对查询无疑是一种很大的负担，如果条件再复杂一点，对整个语句的分析也是很糟糕的。关于阿里开发规范中定义超过3张表的join查询是被禁止的 (未查证)，这个可能只是为了开发规范和管理，从技术角度出发，其实是没有这样的原则性问题的。\n解决方案：使用SplitQuery，从字面意义就可以理解，即将这些join查询拆分成单个查询来执行\n示例代码（推荐）：\n1 2 3 4 5 6 7 8 9 var data = ctx.As .Include(x =\u0026gt; x.Bs) .Include(x =\u0026gt; x.Cs) .ThenInclude(x =\u0026gt; x.D1s) .Include(x =\u0026gt; x.Cs) .ThenIncude(x =\u0026gt; x.C1s) .ThenInclude(x=\u0026gt;x.D2s) .AsSplitQuery() //设置为拆分查询 .ToList(); 当然也可以在全局进行配置 (但是一般不推荐这样做，最好根据每个查询的实际情况，使用上面推荐的方式)\n1 builder.Services.AddDbContext\u0026lt;CRSGEntityDbContext\u0026gt;(options =\u0026gt; options.UseSqlServer(builder.Configuration[\u0026#34;ConnectionStrings:FiinGroupDB\u0026#34;], o =\u0026gt; o.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery))); 生成的sql\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 SELECT [a].[Id], [a].[OtherColumns] FROM [As] AS [a] SELECT [b].[Id], [b].[AId], [b].[OtherColumns] FROM [Bs] AS [b] INNER JOIN [As] AS [a] ON [b].[AId] = [a].[Id] SELECT [c].[Id], [c].[AId], [c].[OtherColumns] FROM [Cs] AS [c] INNER JOIN [As] AS [a] ON [c].[AId] = [a].[Id] SELECT [d1].[Id], [d1].[CId], [d1].[OtherColumns] FROM [D1s] AS [d1] INNER JOIN [Cs] AS [c] ON [d1].[CId] = [c].[Id] WHERE [c].[AId] IN (SELECT [a].[Id] FROM [As] AS [a]) SELECT [c1].[Id], [c1].[CId], [c1].[OtherColumns] FROM [C1s] AS [c1] INNER JOIN [Cs] AS [c] ON [c1].[CId] = [c].[Id] WHERE [c].[AId] IN (SELECT [a].[Id] FROM [As] AS [a]) SELECT [d2].[Id], [d2].[C1Id], [d2].[OtherColumns] FROM [D2s] AS [d2] INNER JOIN [C1s] AS [c1] ON [d2].[C1Id] = [c1].[Id] WHERE [c1].[CId] IN (SELECT [c].[Id] FROM [Cs] AS [c] WHERE [c].[AId] IN (SELECT [a].[Id] FROM [As] AS [a])) 可以看到查询被拆分成了独立的语句，逻辑更加清晰，对于数据库来说执行效率也会更好。\n注意事项：虽然拆分查询可以通过避免笛尔卡爆炸带来的性能问题，但是也需要根据实际的查询场景来决定是否使用，例如，需要对数据进行排序，分页，分组等操作的时候，为了保证查询结果的正确性，就需要考虑是否要使用拆分查询\n关联话题：关于懒加载，其实懒加载的问题原因就等同于在循环中执行sql语句，示例代码：\n1 2 3 4 5 6 7 8 //在没有显示加载的情况下，直接循环查询子对象 foreach (var blog in context.Blogs.ToList()) { foreach (var post in blog.Posts) { Console.WriteLine($\u0026#34;Blog {blog.Url}, Post: {post.Title}\u0026#34;); } } 观察sql日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (1ms) [Parameters=[], CommandType=\u0026#39;Text\u0026#39;, CommandTimeout=\u0026#39;30\u0026#39;] SELECT [b].[BlogId], [b].[Rating], [b].[Url] FROM [Blogs] AS [b] info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (5ms) [Parameters=[@__p_0=\u0026#39;1\u0026#39;], CommandType=\u0026#39;Text\u0026#39;, CommandTimeout=\u0026#39;30\u0026#39;] SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title] FROM [Post] AS [p] WHERE [p].[BlogId] = @__p_0 info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (1ms) [Parameters=[@__p_0=\u0026#39;2\u0026#39;], CommandType=\u0026#39;Text\u0026#39;, CommandTimeout=\u0026#39;30\u0026#39;] SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title] FROM [Post] AS [p] WHERE [p].[BlogId] = @__p_0 info: Microsoft.EntityFrameworkCore.Database.Command[20101] Executed DbCommand (1ms) [Parameters=[@__p_0=\u0026#39;3\u0026#39;], CommandType=\u0026#39;Text\u0026#39;, CommandTimeout=\u0026#39;30\u0026#39;] SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title] FROM [Post] AS [p] WHERE [p].[BlogId] = @__p_0 ... and so on 正确的做法即使用Include或者Load显示加载数据。\n使用批处理语句 批处理语句是EFCore7 版本中更新的重要功能，解决了以往版本需要借助第三方库来实现数据的批量更新，删除操作，而且在性能上带来了更大的提升\n批量删除 之前版本的做法（不借助第三方库）\n1 2 3 4 5 foreach (var blog in context.Blogs.Where(b =\u0026gt; b.Rating \u0026lt; 3)) { context.Blogs.Remove(blog); } context.SaveChanges(); 使用ExecuteDelete，无论是从语法上还是性能上，批处理操作都优于前者。\n1 context.Blogs.Where(b =\u0026gt; b.Rating \u0026lt; 3).ExecuteDelete(); 如果是EFCore版本低于7.0，也可以使用直接执行sql语句 ExecuteSqlRaw 的方式来进行操作\n1 context.Database.ExecuteSqlRaw(\u0026#34;DELETE FROM [Blogs] WHERE [Rating] \u0026lt; 3\u0026#34;); 批量更新 用法与Delete 基本相同\n1 2 3 context.Blogs .Where(b =\u0026gt; b.Rating \u0026lt; 3) .ExecuteUpdate(setters =\u0026gt; setters.SetProperty(b =\u0026gt; b.IsVisible, false)); 注意事项：目前仅支持关系型数据库，而且需要由于是及时发送上下文请求，所以如果要支持事务，需要使用显示事务来与其他代码组合\n使用非跟踪查询 这个比较简单，在你不需要对查询结果进行任何更新操作的场景下，尽量使用非跟踪查询\n1 2 3 var blogs = context.Blogs .AsNoTracking() .ToList(); 或者\n1 2 context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; var blogs = context.Blogs.ToList(); 测试代码\n1 2 3 4 5 6 7 8 9 10 11 //代码执行前已对数据库进行预热处理 //执行5次 double elapsedTime4 = MeasureTime(() =\u0026gt; context.Blogs.FirstOrDefault(x =\u0026gt; x.Id == 1), 5); double elapsedTime5 = MeasureTime(() =\u0026gt; context.Blogs.AsNoTracking().FirstOrDefault(x =\u0026gt; x.Id == 1), 5); Console.WriteLine($\u0026#34;Tracked time took : {elapsedTime4} ms\u0026#34;); Console.WriteLine($\u0026#34;AsNoTracking() time took : {elapsedTime5} ms\u0026#34;); //Consoles: //Tracked time took : 318.26 ms //AsNoTracking() time took : 229.86 ms 仅投影需要的字段 严格意义上来讲这是一个意识问题，大多数情况下，为了节省代码量，可以直接使用DataSet 定义的对象来直接进行查询，或者使用Include加载关联表数据，但是在遇到大量数据查询或大量的表连接查询的时候，精准的属性投影对性能就会起到很大的影响\n示例代码：\n1 2 3 4 5 6 7 8 var data = ctx.As .Where(x =\u0026gt; x.Name.StartWith(\u0026#34;xxx\u0026#34;)) .ToList(); foreach (var item in data.Bs) { Console.WriteLine($\u0026#34;Name :{item.Name},Id: {item.Id}\u0026#34;); } 上述代码中，我们仅需要查询主表及子表的id和name信息，但是却加载了所有的相关的主表和子表字段，这对性能是一种浪费\n解决方案：通过Select投影需要查询的字段\n1 2 3 4 var data = ctx.As .Where(x =\u0026gt; x.Id=1) .Select(x =\u0026gt; new {x.Id, x.Name}) .ToList(); 个人习惯性做法\n1 2 3 4 5 //1，不依赖于数据库外键的设置 var query = from b in context.Blogs join c in context.Comments on b.blogId equals c.blogId join d in context.Posts on d.commentId equals c.commentId select new A{blogId = b.blogId,postId = d.postId,postValue = d.postValue} 这种做法对多表联查和大数据量的查询很有用 ,但需要注意的是这种做法并不适合需要更新数据的场景，因为 EF 的更改跟踪仅适用于实体实例。\n尽量使用异步方法 EFCore 基本上对所有同步操作方法都提供了对应的异步方法，尽量使用他们避免阻塞，减少对线程的需要和必须发生的线程上下文切换的次数，从而提升性能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //ToListAsync var data = await context.blogs.ToListAsync(); //FirstOrDefaultAsync var item = await context.blogs.FirstOrDefaultAsync(it =\u0026gt; it.Id == 1); item.point=2; //SaveChangesAsync await context.SaveChangesAsync(); //AsAsyncEnumerable var groupedHighlyRatedBlogs = await context.Blogs .AsQueryable() .Where(b =\u0026gt; b.Rating \u0026gt; 3) // server-evaluated .AsAsyncEnumerable() .GroupBy(b =\u0026gt; b.Rating) // client-evaluated .ToListAsync(); 异步编程在efcore中在大多数情况被推荐使用，但是需要注意避免使用异步方法查询文本或二进制数据类型的内容，这样反而会引起性能问题(sqlclient的问题)，issue报告: EF Core - Memory and performance issues with async methods Reading large data (binary, text) asynchronously is extremely slow\n避免混合使用同步和异步方法，当你的程序请求量较大的时候，很可能导致连接池耗尽，从而引起的性能问题。\n使用Find查找单个目标数据 设计为在已知主键时高效查找单个实体。 Find 首先检查实体是否已被跟踪，如果是，则立即返回该实体。 只有当未在本地跟踪实体时，才执行数据库查询，而First/FirstOrDefault会立即查询数据库。\n1 2 3 4 5 6 7 8 9 10 //代码执行前已对数据库进行预热处理 double elapsedTime4 = MeasureTime(() =\u0026gt; context.blogs.Find(1); double elapsedTime5 = MeasureTime(() =\u0026gt; context.blogs.Find(1); Console.WriteLine($\u0026#34;Find() first time took : {elapsedTime4} ms\u0026#34;); Console.WriteLine($\u0026#34;Find() second time took : {elapsedTime5} ms\u0026#34;); //Consoles: //Find() first time took : 268.41 ms //Find() second time took : 0.16 ms 注意，只能通过键查询的时候可以用。\n使用Any判断数据内容 在检查某些数据是否存在的时候，优先使用Any，这样在匹配到第一条数据后，查询就会停止，First因为需要返回数据，增加了数据传输和对象实例化的开销，Count则需要扫描表\n1 2 3 4 5 6 7 8 9 10 11 12 double elapsedTime1 = MeasureTime(() =\u0026gt; context.Blogs.Any(it =\u0026gt; it.Id == 1)); double elapsedTime2 = MeasureTime(() =\u0026gt; context.Blogs.Count(it =\u0026gt; it.Id == 1), 1); double elapsedTime3 = MeasureTime(() =\u0026gt; context.Blogs.FirstOrDefault(it =\u0026gt; it.Id == 1), 1); Console.WriteLine($\u0026#34;Any() time took: {elapsedTime1} ms\u0026#34;); Console.WriteLine($\u0026#34;Count() time took: {elapsedTime2} ms\u0026#34;); Console.WriteLine($\u0026#34;FirstOrDefault() time took: {elapsedTime3} ms\u0026#34;); //Consoles: //Any() time took: 237.42 ms //Count() time took: 239.69 ms //FirstOrDefault() time took: 258.28 ms 使用流式处理 首先了解什么是缓冲和流式处理\n缓冲：将需要的数据全部加载到内存中，用于后续的业务逻辑处理 流式处理：按需获取需要的数据并应用到后续的逻辑处理中 形象的理解，缓冲用水桶把水挑起来，然后倒进缸里，流式处理就是用一根水管把水抽到缸里\n原则上，流式处理查询的内存要求是固定的：无论查询返回 1 行还是 1000 行，内存要求都相同。另一方面，返回的行数越多，缓冲查询需要的内存越多。 对于产生大型结果集的查询，这可能是一个重要的性能因素。 反之，如果你的查询结果量很小，那么使用缓冲的效果可能返回会更好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //一次性将数据加载出来 var blogsList = context.Posts.Where(p =\u0026gt; p.Title.StartsWith(\u0026#34;A\u0026#34;)).ToList(); var blogsArray = context.Posts.Where(p =\u0026gt; p.Title.StartsWith(\u0026#34;A\u0026#34;)).ToArray(); //使用流式处理，每次处理一行 foreach (var blog in context.Posts.Where(p =\u0026gt; p.Title.StartsWith(\u0026#34;A\u0026#34;))) { //do some things... SomeDotNetMethod(blog) } // 也可以使用AsEnumerable实现 var doubleFilteredBlogs = context.Posts .Where(p =\u0026gt; p.Title.StartsWith(\u0026#34;A\u0026#34;)) // 执行数据库查询 .AsEnumerable() .Where(p =\u0026gt; SomeDotNetMethod(p)); //执行客户端操作 流式处理适合处理大量数据需要进行某些业务逻辑的加工或执行，但是数据库又无法支持响应的方法或函数，这个时候可以适用流式处理来进行操作。\n使用SQL查询 在某些特殊的情况下，例如一些复杂的sql查询，无法直接使用linq语法来实现的，EFCore也支持直接使用SQL语句进行查询或数据更新操作\n基本查询(实体) 场景：最终返回的结果与Dataset中定义的实体一致\n1 2 3 4 5 6 7 8 9 10 11 //使用FromSql //执行表查询 var blogs = context.Blogs .FromSql($\u0026#34;SELECT * FROM dbo.Blogs\u0026#34;) .ToList(); //执行存储过程查询返回实体 var blogs = context.Blogs .FromSql($\u0026#34;EXECUTE dbo.GetMostPopularBlogs\u0026#34;) .ToList(); 标量查询(非实体) 场景：最终返回的结果为自定义结构，而非数据库实体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //使用SqlQuery //执行查询，返回单个字段 var ids = context.Database .SqlQuery\u0026lt;int\u0026gt;($\u0026#34;SELECT [BlogId] FROM [Blogs]\u0026#34;) .ToList(); //执行查询，返回自定义数据结构 var comments = context.Database .SqlQuery\u0026lt;int\u0026gt;($\u0026#34;SELECT b.[BlogId],c.[CommnetContent] FROM [Blogs] b JOIN [Comments] c on b.BlogId = c.BlogId\u0026#34;) .ToList(); public class CustomBlog{ public int BlogId public string CommnetContent } 执行非查询SQL 场景：提交更新，删除等操作，不关注返回结果\n1 2 3 4 5 6 //使用ExecuteSql //执行更新 context.Database.ExecuteSql($\u0026#34;UPDATE [Blogs] SET [Url] = NULL WHERE Id =1\u0026#34;); //执行删除 context.Database.ExecuteSql($\u0026#34;DELETE FROM [Blogs] WHERE Id =1\u0026#34;); SQL参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //使用FromSql //此代码无效，因为数据库不允许将列名（或架构的任何其他部分）参数化 var propertyName = \u0026#34;User\u0026#34;; var propertyValue = \u0026#34;johndoe\u0026#34;; var blogs = context.Blogs .FromSql($\u0026#34;SELECT * FROM [Blogs] WHERE {propertyName} = {propertyValue}\u0026#34;) .ToList(); //正确姿势：使用 FromSqlRaw var columnName = \u0026#34;Url\u0026#34;; var columnValue = new SqlParameter(\u0026#34;columnValue\u0026#34;, \u0026#34;http://SomeURL\u0026#34;); var blogs = context.Blogs .FromSqlRaw($\u0026#34;SELECT * FROM [Blogs] WHERE {columnName} = @columnValue\u0026#34;, columnValue) .ToList(); 其他关联性优化 除了针对EFCore本身的一些优化技巧之外，还有一些技巧可以帮助我们提升数据查询的效率,我们可以利用vs的调试工具帮助我们监听内存使用,CPU占用率等指标，查找瓶颈，总结主要从以下几个方面进行优化\n尽量避免循环内查询，分析实际的业务逻辑，尽可能的一次性从数据库加载所有需要的数据，再进行循环处理 分片处理条件数据,例如使用Chunk，使用流式处理大批量的数据集的运算 使用合理的数据结构，例如在不关注数据顺序的场景下使用Dictionary或HashSet代替List等 使用缓存减少热点数据的访问（按需设计） 使用数据表索引及物化视图（数据库） 采用分库分表，读写分离，使用ES进行检索（架构级优化） 利用多线程并发提升效率（不到万不得已，慎用） 总结 EFCore的优化主要是从几个方面来进行：\n1.减少数据库的交互，通过连接复用，上下文缓存等\n2.减少内存的使用，例如使用流式处理，分页查询等\n3.降低查询复杂度，尽量在程序中处理复杂的逻辑\n保持良好的编码习惯，使用正确的数据结构和处理逻辑，优化应该是渐进式的，先正确的满足需求，在遇到性能问题的时候借助代码或工具去分析瓶颈，再去进行针对性的优化，不要为了优化而牺牲需求和浪费工作量。\n最后留给大家一段问题代码示例，感兴趣的童鞋可以尝试利用上述手段优化这段代码，看看效率提升有多少：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 var configuration = new ConfigurationBuilder() .SetBasePath(AppDomain.CurrentDomain.BaseDirectory) .AddUserSecrets\u0026lt;Program\u0026gt;() .AddJsonFile(\u0026#34;appsettings.json\u0026#34;, optional: true, reloadOnChange: true) .Build(); var serviceProvider = new ServiceCollection() .AddDbContext\u0026lt;YouContext\u0026gt;(options =\u0026gt; options.UseSqlServer(configuration[\u0026#34;ConnectionStrings:YourContext\u0026#34;]) .EnableSensitiveDataLogging() .UseLoggerFactory(LoggerFactory.Create(builder =\u0026gt; { builder.AddConsole().AddFilter((category, level) =\u0026gt; category == DbLoggerCategory.Database.Command.Name \u0026amp;\u0026amp; level == LogLevel.Information); }))) .BuildServiceProvider(); using (var scope = serviceProvider.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService\u0026lt;YourContext\u0026gt;(); context.Database.SetCommandTimeout(999); var data = context.RELATIONSHIP.Where(x =\u0026gt; x.workflow_state == 3).OrderBy(it =\u0026gt; it.relationship_guid).Take(100000).ToList(); var tempData = data.Select(it =\u0026gt; new Temp { aId = it.entity_from_guid, bId = it.entity_to_guid, deg = 0 }).ToList(); foreach (var item in tempData) { item.deg = GetInterConnectResult(item.aId, item.bId); } int GetInterConnectResult(Guid aId, Guid bId) { HashSet\u0026lt;Bo\u0026gt; boData = new(); for (int i = 1; i \u0026lt;= 3; i++) { if (boData.Any(it =\u0026gt; it.guid == bId)) break; var addIds = boData.Where(it =\u0026gt; it.deg == i - 1).Select(it =\u0026gt; it.guid).Distinct().ToList(); var addRelationships = context.Table1.Where(it =\u0026gt; addIds.Contains(it.aid) || addIds.Contains(it.bid)); var addDegEntities = addRelationships.Select(it =\u0026gt; new { efguid = it.aid, etguid = it.bid }).Union(addRelationships.Select(it =\u0026gt; new { efguid = it.bid, etguid = it.aid })) .Select(it =\u0026gt; new Bo { guid = it.etguid, deg = i }) .ToHashSet() ?? new(); boData.UnionWith(addDegEntities ?? new()); } return boData?.OrderByDescending(it =\u0026gt; it.deg)?.FirstOrDefault(it =\u0026gt; it.guid.Equals(bId))?.deg ?? 0; } } ","date":"2024-08-06T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/ef-core-performance-optimization-tips/","title":"EF Core性能优化技巧"},{"content":"第一种方式（基于 Application 类的静态方法）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public partial class App : Application { public IServiceProvider ServiceProvider { get; } public new static App Current =\u0026gt; (App)Application.Current; public App() { ServiceProvider = ConfigureServices(); } private static IServiceProvider ConfigureServices() { var services = new ServiceCollection(); services.AddSingleton\u0026lt;MainWindow\u0026gt;(); services.AddSingleton\u0026lt;MainWindowViewModel\u0026gt;(); services.AddDbContext\u0026lt;DefaultDbContext\u0026gt;(); services.AddSingleton\u0026lt;ILogger\u0026gt;(_ =\u0026gt; { return new LoggerConfiguration() .MinimumLevel.Debug() .WriteTo.File(\u0026#34;Log/log.txt\u0026#34;, rollingInterval: RollingInterval.Day) .CreateLogger(); }); return services.BuildServiceProvider(); } private void Application_Startup(object sender, StartupEventArgs e) { var mainWindow = ServiceProvider.GetRequiredService\u0026lt;MainWindow\u0026gt;(); mainWindow.Show(); } } 1 2 3 4 5 6 7 \u0026lt;Application x:Class=\u0026#34;Wpf_onlyDI.App\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:local=\u0026#34;clr-namespace:Wpf_onlyDI\u0026#34; Startup=\u0026#34;Application_Startup\u0026#34;\u0026gt; \u0026lt;Application.Resources /\u0026gt; \u0026lt;/Application\u0026gt; 1 2 3 4 5 6 7 8 public partial class MainWindow : Window { public MainWindow(MainWindowViewModel viewModel) { InitializeComponent(); this.DataContext = viewModel; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public partial class MainWindowViewModel : ObservableObject { private readonly ILogger _logger; [ObservableProperty] private string title = \u0026#34;hello\u0026#34;; public MainWindowViewModel(ILogger logger) { this._logger = logger; _logger.Information(title); } } 第二种方式（基于 .NET Generic Host,仅仅.NET Core）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public partial class App : Application { private static readonly IHost _host = Host.CreateDefaultBuilder() .ConfigureAppConfiguration(c =\u0026gt; { c.SetBasePath(AppContext.BaseDirectory); }) .ConfigureServices(services =\u0026gt; { services.AddHostedService\u0026lt;ApplicationHostService\u0026gt;(); services.AddSingleton\u0026lt;MainWindow\u0026gt;(); services.AddSingleton\u0026lt;MainWindowViewModel\u0026gt;(); services.AddDbContext\u0026lt;DefaultDbContext\u0026gt;(); }) .ConfigureLogging(logging =\u0026gt; { logging.ClearProviders(); Log.Logger = new LoggerConfiguration() .WriteTo.File(\u0026#34;Log/log.txt\u0026#34;, rollingInterval: RollingInterval.Day) .CreateLogger(); logging.AddSerilog(Log.Logger); }) .Build(); private void OnStartup(object sender, StartupEventArgs e) { _host.Start(); } private void OnExit(object sender, ExitEventArgs e) { _host.StopAsync().Wait(); _host.Dispose(); } public static T GetRequiredService\u0026lt;T\u0026gt;() where T : class { return _host.Services.GetRequiredService\u0026lt;T\u0026gt;(); } } 1 2 3 4 5 6 7 8 9 10 \u0026lt;Application x:Class=\u0026#34;Wpf_Generic_Host.App\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026#34; xmlns:x=\u0026#34;http://schemas.microsoft.com/winfx/2006/xaml\u0026#34; xmlns:local=\u0026#34;clr-namespace:Wpf_Generic_Host\u0026#34; Startup=\u0026#34;OnStartup\u0026#34; Exit=\u0026#34;OnExit\u0026#34; \u0026gt; \u0026lt;Application.Resources /\u0026gt; \u0026lt;/Application\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 internal class ApplicationHostService : IHostedService { private readonly IServiceProvider _serviceProvider; public ApplicationHostService(IServiceProvider serviceProvider) { this._serviceProvider = serviceProvider; } public async Task StartAsync(CancellationToken cancellationToken) { await HandleActivationAsync(); } public Task StopAsync(CancellationToken cancellationToken) { return Task.CompletedTask; } /// \u0026lt;summary\u0026gt; /// Creates main window during activation. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; private Task HandleActivationAsync() { if (Application.Current.Windows.OfType\u0026lt;MainWindow\u0026gt;().Any()) { return Task.CompletedTask; } var mainWindow = _serviceProvider.GetRequiredService\u0026lt;MainWindow\u0026gt;(); mainWindow.Loaded += MainWindow_Loaded; mainWindow?.Show(); return Task.CompletedTask; } private void MainWindow_Loaded(object sender, RoutedEventArgs e) { if (sender is not MainWindow mainWindow) { return; } //_ = mainWindow.NavigationView.Navigate(typeof(DashboardPage)); } } ","date":"2024-08-06T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/wpf-injection/","title":"WPF中的依赖注入方法比较"},{"content":"作为 C# 开发人员，学习更高级的技术可以帮助您编写更简洁、更高效和更具创新性的代码。在本文中，我们将探讨一些十个高级 C# 技巧，这些技巧是为想要突破 C# 极限的更有经验的开发人员量身定制的。这些技巧可以提高代码的性能、可读性和可维护性。\n利用元组获取多个返回值 传统上，要从方法返回多个值，开发人员必须使用参数并创建自定义类或结构。但是，C# 7 引入了元组，这使得这样做更容易、更易读。\n1 2 3 4 public (int sum, int product) Calculate(int a, int b) { return (a + b, a * b); } 此方法简化了对多个返回值的处理，并提高了代码的清晰度。\n模式匹配增强功能 C# 7 及更高版本引入了强大的模式匹配功能，允许更富有表现力和简洁的类型检查和转换。\n1 2 3 4 5 6 7 8 9 10 11 public void ProcessShape(object shape) { if (shape is Circle c) { Console.WriteLine($\u0026#34;Circle with radius: {c.Radius}\u0026#34;); } else if (shape is Square s) { Console.WriteLine($\u0026#34;Square with side: {s.Side}\u0026#34;); } } 此技术减少了样板代码的数量，并使代码更易于阅读。\n使用本地函数进行封装 在 C# 7 中，引入了本地函数，这些函数允许您在另一个方法中定义方法。这些函数对于封装仅在特定方法中有意义的帮助程序方法特别有用。\n1 2 3 4 5 public IEnumerable\u0026lt;int\u0026gt; Fibonacci(int n) { int Fib(int term) =\u0026gt; term \u0026lt;= 2 ? 1 : Fib(term - 1) + Fib(term - 2); return Enumerable.Range(1, n).Select(Fib); } 局部函数可以从封闭方法访问变量，这提供了一种实现复杂逻辑的简洁方法。\n简洁代码的表达式成员 表达式成员有助于使代码更简洁，因为它们允许在一行代码上实现方法、属性和其他成员。\n1 2 3 4 5 public class Person { public string Name { get; set; } public override string ToString() =\u0026gt; $\u0026#34;Name: {Name}\u0026#34;; } 此功能在最新版本的 C# 中得到了扩展，使定义轻型类成员变得更加容易。\n不可变数据类型的只读结构 只读结构非常适合创建不可变数据类型。这意味着对象一旦创建，就无法更改。\n1 2 3 4 5 6 7 public readonly struct Point { public double X { get; } public double Y { get; } public Point(double x, double y) =\u0026gt; (X, Y) = (x, y); } 此构造可用于表示小型、不可变的数据类型，例如坐标或复数。\n用于性能优化的 Ref 返回和局部变量 Ref 返回和局部变量允许方法返回对变量的引用，而不是值本身。这可以显著提高大型对象的性能。\n1 2 3 4 5 6 7 8 9 public ref int Find(int[] numbers, int target) { for (int i = 0; i \u0026lt; numbers.Length; i++) { if (numbers[i] == target) return ref numbers[i]; } throw new IndexOutOfRangeException(\u0026#34;Not found\u0026#34;); } 此功能在处理大型数据结构的性能敏感代码中特别有用。\n使用丢弃来忽略不需要的退货 丢弃是一项高级功能，允许开发人员跳过他们不感兴趣的参数或元组。这使得代码更具可读性且更易于维护。\n1 var (_, product) = Calculate(3, 4); // Only interested in the product 这样可以更轻松地处理返回多个值的方法，因为您只需要其中的几个值。\n用于简化 Null 检查的 Null 合并赋值 null 合并赋值运算符简化了将值赋值给变量的过程（当变量可能为 null 时）。??=\n1 2 3 List\u0026lt;int\u0026gt; numbers = null; numbers ??= new List\u0026lt;int\u0026gt;(); numbers.Add(1); 此运算符可减少确保在使用对象之前创建对象所需的代码量。\n用于轻量级数据结构的 ValueTuple ValueTuple 是 Tuple 数据结构的轻量级替代方法，它提供了一种更节省内存的方法来管理值集合。\n1 2 var person = (Name: \u0026#34;John\u0026#34;, Age: 30); Console.WriteLine($\u0026#34;{person.Name} is {person.Age} years old.\u0026#34;); ValueTuple 对于不需要类开销的临时数据结构特别有用。\n具有 IAsyncEnumerable 的异步流 C# 8 中引入的异步流允许对异步加载的集合实现异步迭代。这显著提高了处理流数据或受 I/O 限制的应用程序的性能。\n1 2 3 4 5 6 7 8 public async IAsyncEnumerable\u0026lt;int\u0026gt; GetNumbersAsync() { for (int i = 0; i \u0026lt; 10; i++) { await Task.Delay(100); // Simulate asynchronous work yield return i; } } 这允许使用 来使用异步流，从而更容易编写高效且可读的异步代码。await foreach\nC# 的演变引入了一些功能，可提高其代码的可读性、可维护性和性能。其中包括元组、模式匹配和异步流，这对于在 .NET 生态系统中创建更高效、更现代的 C# 应用程序至关重要。\n通过有效利用这些工具，开发人员可以提高应用程序性能、改进其编码风格并提高软件质量。通过掌握这些功能，开发人员可以确保以符合项目需求的方式使用它们，从而释放其成功开发的全部潜力。\n","date":"2024-08-05T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/10-advanced-techniques/","title":"10 Advanced Techniques"},{"content":"本文告诉大家几个不同的方法在 WPF 里，使用多线程修改或创建 ObservableCollection 列表的数据\n需要明确的是 WPF 框架下，非 UI 线程直接或间接访问 UI 是不合法的，设计如此。如此设计可以极大规避新手使用多线程造成的多线程安全问题，由于多线程安全的问题难以定位，以及解决多线程问题需要较多的专业知识。一个优秀的框架从设计上，一定需要满足不同层次开发者接入的需求。大部分微软出品的库和框架都是十分照顾到初学者的，因此默认只开单线程模型的 WPF 框架，将在开发者没有经过 Dispatcher 调度器而直接或间接访问或修改 UI 时，抛出异常\n理解了以上这一点，也就了解了为什么跨线程处理 ObservableCollection 数据，大多数时候都会抛出 System.NotSupportedException:“该类型的 CollectionView 不支持从调度程序线程以外的线程对其 SourceCollection 进行的更改。” 等异常\n在开始之前，还需要理清另一个概念，那就是 ObservableCollection 是非线程安全的。非线程安全与是否不允许非 UI 线程访问 UI 元素是完全两回事。非线程安全的类型，推荐是单一的时刻，仅有单个线程进行处理，也就是单个线程进行读写等。而 非 UI 线程访问 UI 元素是限制只有 UI 线程才能合法访问 UI 线程创建的元素。具体来说就是 ObservableCollection 是可以在任意线程创建和修改的，但是由于 ObservableCollection 是非线程安全的，因此推荐是单一的时刻，仅有单个线程进行处理。如果 ObservableCollection 被 UI 元素捕获，例如加入到 ItemsSource 里面，那么此时的 ObservableCollection 不仅只能被单一线程处理，还要求这个线程是 UI 线程\n根据以上描述，可以了解到，在 WPF 里面，如果有较多数据量，想要多线程处理 ObservableCollection 集合，可以采用在非 UI 的后台线程创建 ObservableCollection 对象和修改或添加数据，完成之后再加入到 UI 线程\n为了方便说明，本文新建了一个项目，本文的所有代码都可以在本文后面找到获取方法\n添加一个简单的界面来方便说明，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition\u0026gt;\u0026lt;/RowDefinition\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;Auto\u0026#34;\u0026gt;\u0026lt;/RowDefinition\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;ListView x:Name=\u0026#34;ListView\u0026#34;\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;TextBlock Margin=\u0026#34;10,10,10,10\u0026#34; Text=\u0026#34;{Binding}\u0026#34;\u0026gt;\u0026lt;/TextBlock\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;StackPanel Grid.Row=\u0026#34;1\u0026#34; Orientation=\u0026#34;Horizontal\u0026#34;\u0026gt; \u0026lt;Button x:Name=\u0026#34;Button1\u0026#34; Margin=\u0026#34;10,10,10,10\u0026#34; Click=\u0026#34;Button1_Click\u0026#34;\u0026gt;方式一\u0026lt;/Button\u0026gt; \u0026lt;Button x:Name=\u0026#34;Button2\u0026#34; Margin=\u0026#34;10,10,10,10\u0026#34; Click=\u0026#34;Button2_Click\u0026#34;\u0026gt;方式二\u0026lt;/Button\u0026gt; \u0026lt;Button x:Name=\u0026#34;Button3\u0026#34; Margin=\u0026#34;10,10,10,10\u0026#34; Click=\u0026#34;Button3_Click\u0026#34;\u0026gt;方式三\u0026lt;/Button\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/Grid\u0026gt; 以上的每个按钮分别代表不同的方法，第一个按钮就是对应开始说的第一个方法。先在后台线程创建 ObservableCollection 对象，然后在后台线程完成处理逻辑，最后赋值给 ListView 的 ItemsSource 属性，实现更新界面逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private async void Button1_Click(object sender, RoutedEventArgs e) { var list = await Task.Run(() =\u0026gt; { ObservableCollection\u0026lt;string\u0026gt; data = new ObservableCollection\u0026lt;string\u0026gt;(); for (int i = 0; i \u0026lt; 100; i++) { data.Add(Random.Shared.Next(1000).ToString()); } return data; }); // 以上代码使用 await 等待，可以自动切回主线程 ListView.ItemsSource = list; } 如以上代码，在按钮点击时，进入按钮点击的是 UI 线程。此时在 UI 线程里面，通过 Task.Run 来切换到后台线程，在后台线程完成 list 变量的初始化逻辑。然后再赋值给 ListView 的 ItemsSource 属性\n上面代码符合了上文说的逻辑条件，首先 ObservableCollection 非线程安全，单一的时刻，只有一个线程进行访问。上面代码先是后台线程创建和处理 ObservableCollection 对象，接下来后台线程执行完成，通过 await 自动依靠同步上下文调度到主线程，将后台线程创建的 ObservableCollection 对象赋值给 list 变量，此时的后台线程退出对 ObservableCollection 对象的任何访问，也就是在此单一的时刻，只有后台线程一个线程在访问。接下来进入 ListView.ItemsSource = list 也就是将 list 交给 UI 线程，在此单一的时刻，也只有 UI 线程，一个线程在访问\n在将 ObservableCollection 关联到 UI 线程之前，对 ObservableCollection 的任何处理都不会涉及到访问 UI 元素，因此也就没有了非 UI 线程不能访问 UI 元素的限制。只有在调用 ListView.ItemsSource = list 代码之后，才将 ObservableCollection 关联到 UI 线程。在此代码执行之后，就不能通过后台线程去修改 list 变量对应的对象了，因为此时的修改将会间接在后台线程访问到 UI 元素\n那如果期望是在后台线程处理原有 UI 线程关联的 ObservableCollection 呢？这就是本文的第二个方法。读取 ObservableCollection 的列表元素内容，不会涉及到访问 UI 元素，因此可以在后台线程进行读取列表元素，读取列表元素也就是等于可以对原有的列表拷贝一份\n这里需要再次说明 ObservableCollection 非线程安全，单一的时刻，只有一个线程进行访问才是安全的。换句话说，虽然代码层面上，可以在后台线程拷贝和 UI 线程关联的 ObservableCollection 的列表元素内容，但是此时毕竟 UI 线程和后台线程都拥有访问相同的一个 ObservableCollection 列表的能力，必须从业务上确保只有后台线程在访问，而 UI 线程不会对 ObservableCollection 列表进行任何的改动\n在确保 UI 线程不会改动到 ObservableCollection 列表的时候，可以采用如下方法，在后台线程拷贝一份作为新的 ObservableCollection 对象，然后对此新的对象进行处理。完成之后，再将新的 ObservableCollection 对象赋值给到 UI 进行绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private async void Button2_Click(object sender, RoutedEventArgs e) { // 假定 ListView.ItemsSource 存在源了 if (ListView.ItemsSource is not ObservableCollection\u0026lt;string\u0026gt; list) { // 如果假设失败，强行给一个源 list = new(); ListView.ItemsSource = list; } var newList = await Task.Run(() =\u0026gt; { var data = new ObservableCollection\u0026lt;string\u0026gt;(list); // 模拟对原有的列表进行处理 if (data.Count \u0026gt; 0) { for (int i = 0; i \u0026lt; 100; i++) { data.Move(Random.Shared.Next(data.Count), Random.Shared.Next(data.Count)); } } return data; }); ListView.ItemsSource = newList; } 以上方法可以实现在后台线程对现有的和 UI 绑定的 ObservableCollection 的更改，由于是放在后台线程执行，基本上不需要担心拷贝的耗时\n第三个方法是自己实现一个类似 ObservableCollection 的类型。在 WPF 里面，只要一个集合类型的对象继承了 INotifyCollectionChanged 接口，即可在集合变更的时候，通过 WPF 框架监听 CollectionChanged 事件重新更新 UI 元素，自己实现的代码大概如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class FooList\u0026lt;T\u0026gt; : Collection\u0026lt;T\u0026gt;, INotifyCollectionChanged { protected override void InsertItem(int index, T item) { base.InsertItem(index, item); Application.Current.Dispatcher.InvokeAsync(() =\u0026gt; { CollectionChanged?.Invoke(this, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item, index)); }); } protected override void RemoveItem(int index) { var item = this[index]; base.RemoveItem(index); Application.Current.Dispatcher.InvokeAsync(() =\u0026gt; { CollectionChanged?.Invoke(this, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, item, index)); }); } protected override void SetItem(int index, T item) { var oldItem = this[index]; base.SetItem(index, item); Application.Current.Dispatcher.InvokeAsync(() =\u0026gt; { CollectionChanged?.Invoke(this, new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace, item, oldItem, index)); }); } public event NotifyCollectionChangedEventHandler? CollectionChanged; } 如上面代码可以看到，在集合变更的代码里面，都通过 Dispatcher 调度到 UI 线程触发事件用来通知。依靠此机制可以实现在后台线程处理时，依然是让此 FooList 对应的对象是绑定在 UI 线程上\n使用 FooList 的例子如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 private async void Button3_Click(object sender, RoutedEventArgs e) { if (ListView.ItemsSource is not FooList\u0026lt;string\u0026gt; list) { list = new FooList\u0026lt;string\u0026gt;(); ListView.ItemsSource = list; } await Task.Run(() =\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { list.Add(Random.Shared.Next(100).ToString()); } }); await Task.Delay(TimeSpan.FromSeconds(1)); await Task.Run(() =\u0026gt; { for (int i = 0; i \u0026lt; 10; i++) { list.RemoveAt(i); } }); await Task.Delay(TimeSpan.FromSeconds(1)); await Task.Run(() =\u0026gt; { for (int i = 0; i \u0026lt; 10; i++) { list[i] = i.ToString(); } }); } 以上的 FooList 只是一个例子，用于告诉大家可以使用 INotifyCollectionChanged 的方式自己实现在集合变更的时候通知主线程，而集合的处理本身可以放在其他的线程。但是这个方法在使用的时候，必须关注线程安全问题。例如以上的代码，如果没有关注线程安全，在通知 UI 线程集合变更之后，刚好 UI 线程去读取此集合新的值的时候，集合本身就被其他线程更改了内容，那么此时的逻辑就不是符合预期的\n以上的代码放在 github 和 gitee 欢迎访问\n可以通过如下方式获取本文的源代码，先创建一个空文件夹，接着使用命令行 cd 命令进入此空文件夹，在命令行里面输入以下代码，即可获取到本文的代码\n1 2 3 git init git remote add origin https://gitee.com/lindexi/lindexi_gd.git git pull origin df7d9da863047fa0a46bc97e782b054da63fc394 以上使用的是 gitee 的源，如果 gitee 不能访问，请替换为 github 的源\n1 2 git remote remove origin git remote add origin https://github.com/lindexi/lindexi_gd.git 获取代码之后，进入 LeejurkawbaicarkeNayqechurcear 文件夹\n","date":"2023-12-19T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/wpf_dispatcher/","title":"WPF多线程下跨线程处理ObservableCollection数据"},{"content":" 委托要解决的问题：\n函数传参：回调函数，linq表达式 基于委托声明事件，事件可以注册（按钮点击\u0026hellip;） 委托本制是一个引用类型，所以可以实例化\n委托是一个函数指针\n事件和委托最大的区别是： 对于委托来说，任何能得到这个委托引用的代码都可以调用它的Invoke方法来。 而事件只能在其被定义的类里才能调用Invoke，这个类的子类都不可以！event其实就是限制委托的invoke不能被乱调用，就是起到安全作用\n事件最重要的安全性居然没提到太不应该了。 事件和属性是类似的东西。属性是对字段进行封装，而事件是对特殊用途的委托类型的字段进行封装。属性本质是两个方法，也就是两个访问器（get,set），在使用自动属性的时候会自动生成一个私有字段；而事件本质上也是两个方法(add,remove)，声明自动事件的时候也会自动生成一个私有字段，并且和事件完全同名\n事件除了保护委托不让外部查看调用列表、移除其他委托、不能赋空、不能调用等保护作用外，没有其他作用\n事件是对委托的一种封装\n事件说白了是 C# 提供的语法糖，效果是: 1.将委托以私有变量的形式封装在类内，不让外面访问 2.对于委托进行了封装，从而定义add与remove 方法 3.在 add 与 remove 中通过互锁的方式提供了线程安全性\n","date":"2023-09-06T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/delegate_event/","title":"委托与事件"},{"content":"HTTP与HTTPS作为互联网数据传输的核心协议，其通信机制与安全特性深刻影响着现代网络应用的可靠性与用户体验。本文将解析两者的通信流程、安全机制及核心差异。\nHTTP的通信机制 先来看看HTTP是什么吧。\nHTTP基于TCP/IP协议栈，采用经典客户端-服务器模型：\nTCP连接建立\n通过三次握手创建可靠传输通道（源IP:端口 ↔ 目标IP:端口），默认端口80。 请求-响应交互\n浏览器发起到服务器的 TCP 连接。 1 2 GET /index.html HTTP/1.1 Host: www.baidu.com 服务器处理与响应\n服务器接收来自浏览器的 TCP 连接。 1 2 3 4 HTTP/1.1 200 OK Content-Type: text/html Content-Length: 1234 \u0026lt;html\u0026gt;...\u0026lt;/html\u0026gt; 交换信息\n浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。\n连接终止\n完成传输后通过四次挥手断开连接，关闭 TCP 连接。\nHTTPS的进化 HTTPS在HTTP与TCP层之间插入SSL/TLS加密层，通过三重防护机制应对安全威胁：\n安全威胁 防护机制 实现方式 数据窃听 AES-256等对称加密 会话密钥动态协商 数据篡改 SHA-256摘要算法 数字签名验证数据完整性 身份伪造 X.509数字证书体系 CA机构签发服务器身份证书 那么，SSL 和 TLS 的区别是什么呢？\n总的来说，SSL 和 TLS 没有太大的区别。\nSSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，新版本被命名为 TLS 1.0。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS。\nHTTPS握手流程：\nClient Hello：客户端发送支持的加密套件+随机数 Server Hello：服务器选择加密套件+证书+随机数 密钥交换：ECDHE算法生成预主密钥 会话密钥：通过HKDF算法生成加密密钥 加密通信：应用层数据使用对称加密传输 如下图所示，以TLS层为例。\nHTTP与HTTPS的不同 在协议层看看它们有什么不同。\n对比维度 HTTP HTTPS 传输加密 明文传输 SSL/TLS加密传输 端口号 80 443 证书要求 无需证书 需CA签发数字证书 响应速度 RTT 3次 RTT 5-7次（支持会话恢复） 头部结构 无加密标识 包含加密协议版本等安全参数 资源消耗 低 增加15-20% CPU负载 HTTPS安全机制解析 混合加密体系\n结合非对称加密（RSA/ECC）的安全密钥交换与对称加密（AES）的高效数据加密，兼顾安全与性能。 证书链验证\n通过根证书→中间证书→服务器证书的信任链验证，防止中间人攻击。OCSP协议实时检查证书吊销状态。 HSTS策略\n强制浏览器使用HTTPS连接，防范SSL剥离攻击。 总结 端口号：HTTP 默认是 80，HTTPS 默认是 443。 URL 前缀：HTTP 的 URL 前缀是 http://，HTTPS 的 URL 前缀是 https://。 安全性和资源消耗：HTTP协议基于TCP协议构建，其传输的数据均为明文形式，且通信双方无法验证彼此身份。而HTTPS作为HTTP的安全演进版本，其通信架构分为两层：底层通过SSL/TLS协议与TCP建立安全通道，上层则承载经过加密处理的HTTP通信。该加密体系采用混合加密机制，即使用服务器数字证书中的公钥对对称会话密钥进行非对称加密传输，实际数据传输阶段则采用高效对称加密算法。相较于HTTP，HTTPS通过双重加密机制显著提升了安全性，但同时也因加解密运算增加了服务器的计算负载。 ","date":"2023-02-28T00:00:00Z","permalink":"https://MorningCigarette.github.io/p/http_and_https/","title":"HTTP and HTTPS"}]